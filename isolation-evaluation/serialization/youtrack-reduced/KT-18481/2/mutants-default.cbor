øiexportTaggdefaultnoriginalSamplex/
object A {
val a = B.b
}
object B
val b = A.a
gmutantsüxz

val e = true
when (e) {
 true -> {object A {
val a = B.b
}}
 else -> {object A {
val a = B.b
}}
}

object B
val b = A.a
xe
object A {
val a = B.b
}

val n = false
try
{object B}
catch(e: Exception){}
finally{}

val b = A.a
xe
object A {
val a = B.b
}
object B

val e = false
try
{val b = A.a}
catch(e: Exception){}
finally{}

xe
object A {
val a = B.b
}
object B
val b = 
val k = true
when (k) {
 true -> {A.a}
 else -> {A.a}
}

x[
object A {

val l = false
if (l) {val a = B.b} else {val a = B.b}

}
object B
val b = A.a
xd
object A {
val a = B.b
}
object B
val b = 
val o = false
when (o) {
 true -> {A}
 else -> {A}
}
.a
xQ
object A {
val a = B.b
}
object B
val b = A.
val p = false
if (p) {a} else {a}

xe
object A {
val a = 
val t = false
try
{B.b}
catch(e: Exception){}
finally{}

}
object B
val b = A.a
xQ
object A {
val a = 
val t = false
if (t) {B} else {B}
.b
}
object B
val b = A.a
xd
object A {
val a = B.
val i = true
try
{b}
catch(e: Exception){}
finally{}

}
object B
val b = A.a
x1
object A {
val a = (B).b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
A b = val.a
x/
object A A
object B
val b = {
val a = B.b
}.a
x/
object A {
val a = B
}
object B.b
val b = A.a
x/
val b = A.a
object B
object A {
val a = B.b
}
x/
object A {
val } = B.b
a
object B
val b = A.a
x/
object A val
val a = B.b
}
object B
{ b = A.a
x/
object A {
val a = B.b
}
object B
val b = A.a
x/
object A {
B
}
object val a = B.b
val b = A.a
x/
object A {
val b = A.a
}
object B
val a = B.b
x/
object A {
val a = A.a.b
}
object B
val b = B
x/
object A {
val a = B.b
}
A
val b = object B.a
x/
object A {
val a a B.b
}
object B
val b = A.=
x/
object A {
val a = B.b
}
object B
= b val A.a
x/
object
object A {
val a = B.b
} B
val b = A.a
x/
object {
val a = B.b
} A
object B
val b = A.a
x/
B
object object A {
val a = B.b
}
val b = A.a
x/
object A {
val a = =
}
object B
val b B.b A.a
x/
object A {
val a = B.b
}
object A.a
val b = B
x/
object A {
val a = B.b
}
object val
B b = A.a
x/
object A {
val a = B.b
}
object .
val b = ABa
x/
object A {
val a = BAb
}
object B
val b = ..a
x/
object A {
val a = val b = A.a.b
}
object B
B
x/
object A {
val a = B.b
.
object B
val b = A}a
x/
object A {
val a = B.b
}
object B
val = b A.a
x/
object A {
val a = B.b
val
object B
} b = A.a
x/
object A .
val a = B.b
}
object B
val b = A{a
x/
object A {
val a = B.b
}
object a
val b = A.B
x/
object val {
val a = B.b
}
object B
A b = A.a
x/
object A {
val a = B.b
}
val b = A.a
object B
x/
A.a
object B
val b = object A {
val a = B.b
}
x/
object A {
val a = B.=
}
object B
val b b A.a
x/
object A {
val a = A.b
}
object B
val b = B.a
x/
object A {
val a = B.b
A
object B
val b = }.a
x/
object A {
val a = Bobject Bb
}
.
val b = A.a
x/
object A .
object B
val b = A{
val a = B.b
}a
x/
object A {
val a = B}b
.
object B
val b = A.a
x/
object b {
val a = B.A
}
object B
val b = A.a
x/
val
object B
object A {
val a = B.b
} b = A.a
x/
object A {
val A = B.b
}
object B
val b = a.a
x/
a
object B
val b = A.object A {
val a = B.b
}
x/
a A {
val a = B.b
}
object B
val b = A.object
x/
.
object B
val b = Aobject A {
val a = B.b
}a
x/
object A {
val a = b.B
}
object B
val b = A.a
x/
object A {
A.a a = B.b
}
object B
val b = val
x/
object A a
object B
val b = A.{
val a = B.b
}
x/
object A {
val a = B.val b = A.a
}
object B
b
x/
object A A.a
object B
val b = {
val a = B.b
}
x/
object A {
val a = val.b
}
object B
B b = A.a
x/
object A {
val a . B.b
}
object B
val b = A=a
x/
object B
object A {
val a = B.b
}
val b = A.a
x/
object = {
val a = B.b
}
object B
val b A A.a
x/
object A {
object
}
val a = B.b B
val b = A.a
x/
object B {
val a = B.b
}
object A
val b = A.a
x/
object A =
val a { B.b
}
object B
val b = A.a
x/
object A {
=
}
object B
val b val a = B.b A.a
x/
object A B.b
val a = {
}
object B
val b = A.a
x/
object A {
val a B.b =
}
object B
val b = A.a
x/
object A {
b a = B.b
}
object B
val val = A.a
x/
object B {
val a = A.b
}
object B
val b = A.a
x/
object . {
val a = B.b
}
object B
val b = AAa
x/
object A {
val a = Bobjectb
}
. B
val b = A.a
x/
object A {
val
}
object B
val a = B.b b = A.a
x/
object A {
.
}
object B
val b = Aval a = B.ba
x/
val a = B.b A {
object
}
object B
val b = A.a
x/
object A {
val a = =.b
}
object B
val b B A.a
x/
object A {
val a } B.b
=
object B
val b = A.a
x/
A A {
val a = B.b
}
object B
val b = object.a
x/
object A {
val a = Bb.
}
object B
val b = A.a
x/
object A {
val a b B.b
}
object B
val = = A.a
x/
object A {
A
}
object B
val b = val a = B.b.a
x/
object A {
val a = BBb
}
object .
val b = A.a
x/
object A {
val a = B.b
}
object B
a b = A.val
x/
object A {
val a A B.b
}
object B
val b = =.a
x/
object A object
{
val a = B.b
} B
val b = A.a
x/
object A {
b a = B.val
}
object B
val b = A.a
x/
object . {
val a = BAb
}
object B
val b = A.a
x/
object A {
val a = val b = A.a
}
object B
B.b
x/
object A {
val val = B.b
}
object B
a b = A.a
x/
object A {
val a = A
}
object B
val b = B.b.a
x/
object A {
val a = B..
}
object B
val b = Aba
x/
object A {
val a = B.A.a
}
object B
val b = b
x/
object A {
val a = B.b
}
object B
val a = A.b
x/
object A {
a a = B.b
}
object B
val b = A.val
x/
object A a
val a = B.b
}
object B
val b = A.{
x/
object A {
val a = b
}
object B
val B.b = A.a
x/
object A {
val a = }.b
B
object B
val b = A.a
x/
object b {
val a = B.b
}
object B
val A = A.a
x/
{ A object
val a = B.b
}
object B
val b = A.a
x/
object A {
= a val B.b
}
object B
val b = A.a
x/
object { A
val a = B.b
}
object B
val b = A.a
x/
object A val b = A.a
object B
{
val a = B.b
}
x/
A
object B
val b = object A {
val a = B.b
}.a
x/
object A {
A a = B.b
}
object B
val b = val.a
x/
object A {
B a = val.b
}
object B
val b = A.a
x/
=
object B
val b object A {
val a = B.b
} A.a
x/
object A {
val a = B.b
}
object B
val A = b.a
x/
object A {
val a = B.b
}
object B
b val = A.a
x/
. A {
val a = Bobjectb
}
object B
val b = A.a
x/
object A {
val a b B.=
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = .Aa
x/
object A {
val a = B.b
}
object val b = A.a
B
x/
object A {
val = a B.b
}
object B
val b = A.a
x/
object A val
object B
{
val a = B.b
} b = A.a
x/
object A {
val a = B.A
}
object B
val b = b.a
x/
val b = A.a A {
val a = B.b
}
object B
object
x/
object A {
val a = a
}
object B
val b = A.B.b
x/
object A {
val a = a.b
}
object B
val b = A.B
x/
object A b
object B
val {
val a = B.b
} = A.a
x/
object A {
val a = B.}
b
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b a A.=
x/
object A val b = A.a
val a = B.b
}
object B
{
x/
B A {
val a = object.b
}
object B
val b = A.a
x/
object A {
}
val a = B.b
object B
val b = A.a
x/
object A {
val . = Bab
}
object B
val b = A.a
x/
object A {
val a = B.b
}
A B
val b = object.a
x/
object A {
val a = B.b
}
=
val b object B A.a
x/
object A {
= a = B.b
}
object B
val b val A.a
x/
object A {
val . = B.b
}
object B
val b = Aaa
x/
object A {
a val = B.b
}
object B
val b = A.a
x/
object = {
val a A B.b
}
object B
val b = A.a
x/
object A B
val a = B.b
}
object {
val b = A.a
x/
object A {
val a val b = A.a B.b
}
object B
=
x/
object A b
val a = B.{
}
object B
val b = A.a
x/
object A {
val a = ..b
}
object B
val b = ABa
x/
object A {
val a = B.b
}
A.a
val b = object B
x/
object A {
val B = a.b
}
object B
val b = A.a
x/
object A object B
{
val a = B.b
}
val b = A.a
x/
object B.b {
val a = A
}
object B
val b = A.a
x/
object A {
val A.a = B.b
}
object B
val b = a
x/
object A {
val a = object B
}
B.b
val b = A.a
x/
object A {
val a = .
}
object B
val b = AB.ba
x/
object A {
val object = B.b
}
a B
val b = A.a
x/
object A {
b
}
object B
val val a = B.b = A.a
x/
object object {
val a = B.b
}
A B
val b = A.a
x/
object A.a {
val a = B.b
}
object B
val b = A
x/
object A A
val a = B.b
}
object B
val b = {.a
x/
object A {
val a = B.b
}
B object
val b = A.a
x/
object A {
val a = B.b
}
object A
val b = B.a
x/
object A {
val a = B.b
}
. B
val b = Aobjecta
x/
object A {
val a = B=b
}
object B
val b . A.a
x/
object A {
val a = B.b
}
object B
A.a b = val
x/
object A {
val a = B.b
object
} B
val b = A.a
x/
A.a A {
val a = B.b
}
object B
val b = object
x/
object A {
val a = B.b
}
object B
val b A.a =
x/
object A {
val a val B.b
}
object B
= b = A.a
x/
object A {
A.a
}
object B
val b = val a = B.b
x/
object A B
val a = {.b
}
object B
val b = A.a
x/
object A {
val a B B.b
}
object =
val b = A.a
x/
object A {
val a A.a B.b
}
object B
val b = =
x/
object A a
val { = B.b
}
object B
val b = A.a
x/
object A {
val a = .Bb
}
object B
val b = A.a
x/
object A {
val a = Bvalb
}
object B
. b = A.a
x/
object A {
B.b a = val
}
object B
val b = A.a
x/
object A {
val a = object B.b
}
B
val b = A.a
x/
object A {
val a = B.b
}
a B
val b = A.object
x/
object A {
val a = B.b
}
val B
object b = A.a
x/
{
val a = B.b
} A object
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b A =.a
x/
object A {
val a = B.b
a
object B
val b = A.}
x/
object A {
val a = B.b
}
object =
val b B A.a
x/
object B A {
val a = B.b
}
object
val b = A.a
x/
object a {
val A = B.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
val
object B b = A.a
x/
object A {
val B = B.b
}
object a
val b = A.a
x/
object A {
val a = B.object
}
b B
val b = A.a
x/
object A {
a
}
object B
val b = A.val a = B.b
x/
object A {
val a = B.val
}
object B
b b = A.a
x/
object } {
val a = B.b
A
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = a.A
x/
object a {
val a = B.b
}
object B
val b = A.A
x/
object A {
val a = B.b
}
a
val b = A.object B
x/
object A {
val a = Bab
}
object B
val b = A..
x/
val A {
val a = B.b
}
object B
object b = A.a
x/
object A {
val a = B.a
}
object B
val b = A.b
x/
object A {
object a = B.b
}
val B
val b = A.a
x/
object A {
val a = B.object B
}
b
val b = A.a
x/
object A {
val a = B.b
}
b B
val object = A.a
x/
object A {
val a = B.b
}
val b = A.a B
object
x/
. A {
val a = B.b
}
object B
val b = Aobjecta
x/
object A =
val a = B.b
}
object B
val b { A.a
x/
object A {
val a = B.b
=
object B
val b } A.a
x/
object A {
val val b = A.a = B.b
}
object B
a
x/
object A {
. a = Bvalb
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val A.a = b
x/
object A {
val a . B=b
}
object B
val b = A.a
x/
object A {
val a = val
}
object B
B.b b = A.a
x/
object A {
val a = Bval b = A.ab
}
object B
.
x/
object A }
val a = B.b
{
object B
val b = A.a
x/
object A {
val a = B.B
}
object b
val b = A.a
x/
val A {
object a = B.b
}
object B
val b = A.a
x/
object A {
val b = A.a a = B.b
}
object B
val
x/
object A {
val a = B.b
}
object B
val b = Aa.
x/
= A {
val a object B.b
}
object B
val b = A.a
x/
object A {
val a = A.a
}
object B
val b = B.b
x/
object A {
val a = B.b
}
= B
val b object A.a
x4
object A {
val a = B.String
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = A.Int
x^
object A {
            override fun toString(): String = "OK"
        }
object B
val b = A.a
x9
object A {
val a = B.b
}
object B
val b = Game.SCISSORS
xe
companion object : Base(run { { Host.ok() } }) {
        fun ok() = "OK"
    }
object B
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = A.String
x/
object x {
val a = B.b
}
object B
val b = A.a
xf
object Whatever {
    operator fun getValue(thisRef: Any?, prop: Any?) = "OK"
}
object B
val b = A.a
x4
object A {
val a = this@a.s
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = T.a
x1
object A {
val a = B.b
}
object B
val b = A.box
x/
object A {
val a = B.b
}
object B
val b = x.a
x6
object A {
val a = B.b
}
object B
val toString = A.a
x4
object A {
val a = result.b
}
object B
val b = A.a
x/
object A {
val a = B.z
}
object B
val b = A.a
x/
object A {
val a = r.b
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val x = ::foo
x/
object A {
val a = B.b
}
object b
val b = A.a
xA
object A {
val a = B.b
}
object B
val list2 = ArrayList<UInt>()
y ∑
object A {
val a = B.b
}
object A {
    operator fun get(i: Int) = 1
    operator fun set(i: Int, j: Int) {}
    operator fun set(i: Int, x: Any) { throw Exception() }
}
val b = A.a
x3
object A {
val a = B.b
}
object B
val b = s.foo()
x/
object A {
val a = A.b
}
object B
val b = A.a
x1
object A {
val Int = B.b
}
object B
val b = A.a
x0
object A {
val a = zr.b
}
object B
val b = A.a
x9
object A {
val a = B.b
}
object B
val b = Test().test()
x/
object A {
val a = B.b
}
object B
val b = A.x
xC
object A {
val l = Array<Int>(3, {x -> x})
}
object B
val b = A.a
x/
object A {
val a = s.b
}
object B
val b = A.a
x0
object A {
val a = B.b
}
object B
val b = at.a
x7
object A {
private val o = "O"
}
object B
val b = A.a
x4
object A {
val a = B.b
}
object B
val listOf = A.a
xe
object A {
    val a1 = arrayOf(
            object { val fy = "text"}
    )
}
object B
val b = A.a
x4
object String {
val a = B.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = a.a
x2
object A {
val a = Long.b
}
object B
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = String.a
y ù
object A {
val a = B.b
}
object : ResultReceiver<T>() {
        override fun receive(result: Result<T>) {
            f(result)
        }
    }
val b = A.a
x/
object c {
val a = B.b
}
object B
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = Double.a
x4
object equals {
val a = B.b
}
object B
val b = A.a
x/
object A {
val x = B.b
}
object B
val b = A.a
x9
object A {
val a = B.b
}
object B
val b = A("OK")._kind
x/
object A {
val a = B.b
}
object B
val b = C.a
x/
object r {
val a = B.b
}
object B
val b = A.a
x5
object A {
val a = B.b
}
object hasNext
val b = A.a
y ¿
object A {
val a = B.b
}
object Outer: A(1) {
    object O: A(2) {
        override fun foo(): Int {
            val s = super<A>.foo()
            return s + 3
        }
    }
}
val b = A.a
x/
object A {
val a = b.b
}
object B
val b = A.a
x/
object A {
val a = O.b
}
object B
val b = A.a
x/
object A {
val a = e.b
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = A.foo
x3
object A {
val a = B.b
}
object B
val b = state.a
x/
object A {
val a = B.b
}
object B
val b = A.C
x7
object A {
val a = B.b
}
object B
val b = 42.toLong()
x2
object A {
val a = arg2.b
}
object B
val b = A.a
y è
object A {
val a = B.b
}
companion object {
        fun testStatic(ic: InnerClass): NotInnerClass = NotInnerClass(ic.value)
    }
val b = A.a
x3
object A {
val a = B.b
}
object count
val b = A.a
xQ
object A {
var prop: Int = 1
            get() = field++
}
object B
val b = A.a
x5
object A {
val a = Float.NaN
}
object B
val b = A.a
x6
object A {
val a = Y().test()
}
object B
val b = A.a
x`
object A {
val u: Unit = when(En.A) {
    En.A -> {}
    En.B -> {}
  }
}
object B
val b = A.a
x1
object A {
val foo = B.b
}
object B
val b = A.a
x4
object A {
val a = l.add(1)
}
object B
val b = A.a
x5
object A {
val a = B.b
}
object B
val b = X.B.foo()
x/
object A {
val a = A()
}
object B
val b = A.a
x7
object A {
val a = B.b
}
object B
val Companion = A.a
x;
object A {
val a = B.b
}
object B
val b = ::toString.name
x1
object A {
val a = B.b
}
object rem
val b = A.a
x/
object T {
val a = B.b
}
object B
val b = A.a
x1
object A {
val box = B.b
}
object B
val b = A.a
x@
object A {
val a = B.b
}
object B
val list1 = ArrayList<Int>()
xJ
object A {
val a = B.b
}
object B
var t = Throwable("O", Throwable("K"))
x5
object A {
val a = B.b
}
object B
val b = X().zzz()
x3
object A {
val a = Inner.b
}
object B
val b = A.a
x?
object A {
const val M = Int.MIN_VALUE
}
object B
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = a.method
x3
object A {
val value = B.b
}
object B
val b = A.a
x}
object A {

    val _kind: String = when {
        p == "test" -> "OK"
        else -> "fail"
    }

}
object B
val b = A.a
x3
object A {
val a = Named.b
}
object B
val b = A.a
x1
object A {
val a = B.Int
}
object B
val b = A.a
x^
object A {
val a = B.b
}
object B
val my: String = "O"
            get() = { field }() + "K"
x6
object A {
val a = thisRef1.b
}
object B
val b = A.a
yÚ
object A {
val l = {
        p00: A, p01: A, p02: A, p03: A, p04: A, p05: A, p06: A, p07: A, p08: A, p09: A,
        p10: A, p11: A, p12: A, p13: A, p14: A, p15: A, p16: A, p17: A, p18: A, p19: A,
        p20: A, p21: A, p22: A, p23: A, p24: A, p25: A, p26: A, p27: A, p28: A, p29: A ->
        check(p00, 0)
        check(p01, 1)
        check(p02, 2)
        check(p03, 3)
        check(p04, 4)
        check(p05, 5)
        check(p06, 6)
        check(p07, 7)
        check(p08, 8)
        check(p09, 9)
        check(p10, 10)
        check(p11, 11)
        check(p12, 12)
        check(p13, 13)
        check(p14, 14)
        check(p15, 15)
        check(p16, 16)
        check(p17, 17)
        check(p18, 18)
        check(p19, 19)
        check(p20, 20)
        check(p21, 21)
        check(p22, 22)
        check(p23, 23)
        check(p24, 24)
        check(p25, 25)
        check(p26, 26)
        check(p27, 27)
        check(p28, 28)
        check(p29, 29)
        "OK"
    }
}
object B
val b = A.a
xY
object A {
val a = B.b
}
object B
val b = kotlin.experimental.ExperimentalTypeInference
x/
object A {
val a = B.b
}
object B
val f = A.a
x2
object A {
val a = IFoo.b
}
object B
val b = A.a
xA
object A {
val a = B.b
}
object B
val element1 = (-1).toShort()
x?
object A {
val a = ZImpl3().test("OK")
}
object B
val b = A.a
xO
companion object {
        private fun ok() = "OK"
    }
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = A.B
x7
object A {
val a = B.b
}
object B
val Exception = A.a
x5
object A {
val a = B.b
}
object B
val ip = IcInt(1)
x0
object A {
val a = B.b
}
object B
val b = ok.a
x4
object A {
val a = s.n(238)
}
object B
val b = A.a
xA
object A {
val a = B.b
}
object B
val b = Identifier.init(true)
x/
object A {
val a = Z.b
}
object B
val b = A.a
x1
object box {
val a = B.b
}
object B
val b = A.a
xC
object A {
val a = B.b
}
object B
var v1 = ArrayWrapper<String>()
x-
object A {
val a = B.b
}
object B
val z = 2
x1
object A {
val a = foo.b
}
object B
val b = A.a
xL
object A {
val a = B.b
}
object {
        val a by del()
    }
val b = A.a
x;
object A {
val a = B.b
}
object B
val outer = Outer.Inner
x3
object A {
val a = B.b
}
object index
val b = A.a
xf
object A {
val a = B.b
}
object : Local(239L) {
        fun bar(): Boolean = foo()
    }
val b = A.a
x@
object A {
val a = B.b
}
object B
val b = Bug.run().toString()
xD
object A {
val a = B.b
}
object Host {
    var x = 0
}
val b = A.a
xD
object A {
val a = B.b
}
object B
val stack = mutableListOf<Int>()
xA
object A {
val a = B.b
}
object B
val b = A.testSimpleULongLoop
xV
object A {
    override fun getReferencedNameElement() = this
}
object B
val b = A.a
x3
object A {
val a = B.b
}
object B
val b = super.a
xt
object A {
val a = B.b
}
object {
        fun test(): Int {
            return 1 foo 1
        }
    }
val b = A.a
x3
object A {
val a = B.b
}
object B
val b = A().f()
xj
object A {

    companion object {
        fun test () =  { Outer("OK") }()
    }
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = A.l
x4
object A {
val a = B.b
}
object B
val String = A.a
xC
object A {
val a = B.b
}
object B
val b = h.testWithDefaultObj2()
x2
object A {
val a = B.b
}
object B
var p: Int = 4
x1
object A {
val a = B.b
}
object B
val b = A.arg
x6
object A {
val a = B.b
}
object B
val b = plusZero.a
x0
object A {
val a = B.b
}
object B
val or = A.a
x1
object A {
val a = Foo.b
}
object B
val b = A.a
x/
object l {
val a = B.b
}
object B
val b = A.a
x9
object A {
val a = B.b
}
object B
var i : Int? = init()
xu
object A {
val a = B.b
}
companion object {
        var prop: Int = 1
            get() = field++
    }
val b = A.a
x3
object PAPER {
val a = B.b
}
object B
val b = A.a
x0
object A {
val a = B.b
}
object B
val b = A.id
x<
object A {
val a = AssertionError.b
}
object B
val b = A.a
x>
object A {
val a = B.b
}
object B
val element18 = 2.toByte()
x4
object A {
val a = B.b
}
object B
val b = A.range5
x/
object A {
val a = x.b
}
object B
val b = A.a
x]
object A {
val a = B.b
}
companion object {
        fun bar() = A().foo()
    }
val b = A.a
x/
object A {
val a = z.b
}
object B
val b = A.a
x<
object A {
val a = B.b
}
object B
val x: CharSequence = ""
x4
object downTo {
val a = B.b
}
object B
val b = A.a
y,
companion object {
    var xi = 0
    var xin : Int? = 0
    var xinn : Int? = null

    var xl = 0.toLong()
    var xln : Long? = 0.toLong()
    var xlnn : Long? = null

    var xb = 0.toByte()
    var xbn : Byte? = 0.toByte()
    var xbnn : Byte? = null

    var xf = 0.toFloat()
    var xfn : Float? = 0.toFloat()
    var xfnn : Float? = null

    var xd = 0.toDouble()
    var xdn : Double? = 0.toDouble()
    var xdnn : Double? = null

    var xs = 0.toShort()
    var xsn : Short? = 0.toShort()
    var xsnn : Short? = null
  }
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = A.Foo
xu
object A {
val a = B.b
}
private companion object {
        fun xo() = "O"
        fun xk() = "K"
    }
val b = A.a
x4
object A {
val a = String.b
}
object B
val b = A.a
x2
object Kind {
val a = B.b
}
object B
val b = A.a
x0
object A {
val a = B.b
}
object B
val b = A.In
x8
object A {
val a = component2.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object C
val b = A.a
x1
object inc {
val a = B.b
}
object B
val b = A.a
x3
object A {
val a = B.b
}
object B
val b = A.list4
x@
object A {
val a = B.b
}
object B
val foo: Any.() -> Unit = {}
x7
object A {
val MIN_VALUE = B.b
}
object B
val b = A.a
xv
object A {
val a = B.b
}
private companion object {
        override fun toString(): String = "OK"
    }
val b = A.a
xk
companion object {
        init {
            log.append("<clinit>")
        }
    }
object B
val b = A.a
x3
object A {
val a = B.b
}
object list1
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = result.a
x8
object A {
val a = sb.append(i)
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object box
val b = A.a
x>
object A {
val c = a.value.hashCode()
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
var s = ""
x1
object foo {
val a = B.b
}
object B
val b = A.a
xe
object A {
val a = B.b
}
object : Inner("OK") {
            fun ok() = result
        }
val b = A.a
x0
object A {
var i : Base
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val box = A.a
x3
object A {
val Color = B.b
}
object B
val b = A.a
y á
private companion object {
        private fun foo() = on { this }

        override fun toString() = "OK"
    }
object B
val b = A.a
x1
object A {
val Foo = B.b
}
object B
val b = A.a
x=
object A {
val ok = "Fail: Outer.ok"
}
object B
val b = A.a
xC
object A {
val a = B.b
}
object B
val b = L(1234L)::test.invoke()
x2
object A {
val a = B.Long
}
object B
val b = A.a
y ≥
object A {
    val ok = "OK"

    inner class Inner : Base(
            object : Callback {
                override fun invoke() = ok
            }
    )
}
object B
val b = A.a
x6
object A {
val a = 5.toLong()
}
object B
val b = A.a
x2
object A {
val a = B.b
}
object B
val size = A.a
y Æ
object A {
val a = B.b
}
object: ClosedRange<A> {
    override val endInclusive: A
        get() = that
    override val start: A
        get() = this@rangeTo
}
val b = A.a
x1
object A {
val a = B.foo
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = M.a
x%
object B : A()
object B
val b = A.a
x4
object A {
val xx get() = x
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object l
val b = A.a
x2
object A {
val a = B.b
}
object B
val b = A.doit
x/
object A {
val a = B.b
}
object B
val b = A.s
x2
object A {
val a = B.b
}
object test
val b = A.a
x4
object A {
val String = B.b
}
object B
val b = A.a
xM
object A {
val a = B.b
}
object B
val b = (0..10).map(::foo).joinToString()
x/
object A {
val a = B.b
}
object x
val b = A.a
x6
object A {
val a = B.b
}
object B
val b = A.iterator
x:
object A {
val a = B.b
}
object B
val x: IFoo = IC("OK")
x/
object B {
val a = B.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object t
val b = A.a
xp
object A {
val a = B.b
}
object : Base(k = { result = "O"; "K"}() , o = {result += "K"; "O"}()) {}
val b = A.a
x8
object A {
val a = it.hasNext()
}
object B
val b = A.a
x2
object A {
val test = B.b
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = add.a
x4
object A {
val a = B.b
}
object B
val result = A.a
x3
object A {
var result = ""
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = A.A
x5
object A {
val a = B.Boolean
}
object B
val b = A.a
x5
object A {
    val OK = "OK"
}
object B
val b = A.a
x:
object A {
val ns1 = NA(A("abc"))
}
object B
val b = A.a
x/
object d {
val a = B.b
}
object B
val b = A.a
x1
object A {
val a = set.b
}
object B
val b = A.a
x7
object A {
val a = B.b
}
object B
val b = inlineFun.a
x8
object A {
val a = list4.add(i)
}
object B
val b = A.a
x6
object A {
val newValue = B.b
}
object B
val b = A.a
xH
object A {
val a = Foo::bar.set(receiver, null)
}
object B
val b = A.a
xD
object A {
val a = B.b
}
object B
public abstract var text: String
x9
object A {
val a = A().B().bar()
}
object B
val b = A.a
x6
object A {
val a = B.b
}
object B
val b = newValue.a
xK
object A {
val a = B.b
}
object B
val b = A.UnsupportedOperationException
xX
object A {
val a = B.b
}
object B
val Int.valThisRef1: () -> Int get() = fun () = this
xJ
object A {
        fun testB() = s + this@A.s
    }
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = A.ONE
x/
object A {
val a = B.b
}
object B
val b = A.i
xP
object: A("fail") {
   override val v = this@a.v + newv
}
object B
val b = A.a
x7
object A {
val a = B.b
}
object B
val b = local.fn1()
x9
object A {
val a = B.b
}
object B
val sideEffects = A.a
x1
object A {
val a = B.b
}
object B
val b = A().a
x8
object A {
val a = x.toString()
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = A.Z
x-
object A {
val a = B.b
}
object B
var x = 0
x6
object A {
val a = B.b
}
object B
val b = B().test()
x1
object A {
val ok = "OK"
}
object B
val b = A.a
y ö
object A {
val a = B.b
}
companion object : Bar<Foo>("OK") {
        val p = Foo.prop
        val p2 = prop
        val p3 = this.prop
    }
val b = A.a
y ú
object Main {
    fun bar() = myWith(Foo2) {

        val x = object {
            val y = 38["Hello!"]
        }
        x.y
    }
}
object B
val b = A.a
xD
object A {
val a = B.b
}
object B
val outer4 = Outer("propValue4")
x/
object A {
val a = B.b
}
object B
val b = A.c
x0
object A {
val a = B.b
}
object B
val b = f1.a
x/
object A {
val a = B.b
}
object B
val b = A.t
x:
object A {
    fun bar() : String
}
object B
val b = A.a
xM
object A {
val Int.foo: Int
        get() = this + 1
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object A
val b = A.a
x4
object A {
val a = B.SPRING
}
object B
val b = A.a
y ä
object A {
    fun test() = object {
        override fun toString() = ok()
    }.toString()

    fun ok() = "OK"
}
object B
val b = A.a
y ∫
object A {
val a = B.b
}
companion object {
        fun foo() = ROCK
        val bar = PAPER
        val values2 = values()
        val scissors = valueOf("SCISSORS")
    }
val b = A.a
x7
object A {
val KProperty = B.b
}
object B
val b = A.a
x3
object A {
val a = list4.b
}
object B
val b = A.a
xA
object A {
val a = B.b
}
object B
val fDouble = FooDouble(42.1)
x1
object A {
val a = B.b
}
object str
val b = A.a
x6
object toString {
val a = B.b
}
object B
val b = A.a
x<
object A {
var counter: Int? = null
}
object B
val b = A.a
y á
object A {
val x = when (val x = peek()) {
        1 -> "OK"
        2 -> "2"
        else -> "other $x"
    }
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val b = s.a
x7
object A {
val a = B.b
}
object B
val ArrayList = A.a
x9
object A {
val a = B.b
}
object Z2 : Z {

}
val b = A.a
x1
object A {
val a = res.b
}
object B
val b = A.a
x7
object A {
    val foo: String
}
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = bar.a
xA
object A {
    fun hello(id: T) = "O$id"
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object a
val b = A.a
y3
object : Comparator<String?> {

        override fun compare(o1 : String?, o2 : String?) : Int {
            val l1 : Int = o1?.length ?: 0
            val l2 = o2?.length ?: 0
            return l1 - l2
        }

         override fun equals(obj: Any?): Boolean = obj === this
    }
object B
val b = A.a
x1
object A {
val a = B.b
}
object B
val b = D().c
y §
object A {
    var backingB : Int
    var b : Int
        get() = backingB
        set(value: Int) {
            backingB = value
        }
}
object B
val b = A.a
x8
object A {
val a = B.b
}
object component2
val b = A.a
xB
object A {
val a = id('a').compareTo('b')
}
object B
val b = A.a
x/
object s {
val a = B.b
}
object B
val b = A.a
x4
object A {
val a = B.b
}
object append
val b = A.a
x0
object A {
val a = B.b
}
object B
val My = A.a
x7
object A {
val a = B.b
}
object B
val b = A.ArrayList
x7
object A {
val a = B.ArrayList
}
object B
val b = A.a
x3
object A {
val a = B.b
}
object B
val b = Inner.a
x4
object A {
val a = Number.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object R
val b = A.a
xO
object A {
val b : Array<Int?> = arrayOfNulls<Int> (5)
}
object B
val b = A.a
x3
object A {
val Doggy = B.b
}
object B
val b = A.a
x5
object A {
var result = "OK"
}
object B
val b = A.a
y
object C: BaseClass(), I<String> {
    fun f(s: Int) = 1
    fun f(s: String) = 2
    fun Boolean.f() = 3

    var p: Int = 4
    val Int.ext: Int
        get() = 6

    fun <T> g1(t: T): T = t
    val <T> T.g2: T
        get() = this
}
object B
val b = A.a
xG
object A {
val a = B.b
}
object B
override val property: Any = "fail"
xA
object A {
val list4 = ArrayList<Long>()
}
object B
val b = A.a
x<
object {
        val a by del()
    }
object B
val b = A.a
xJ
object A {
    operator fun iterator(): It = It()
}
object B
val b = A.a
x/
object C {
val a = B.b
}
object B
val b = A.a
x0
object A {
val a = B.b
}
object B
val b = A.z1
x"
object A {}
object B
val b = A.a
x4
object A {
val a = B.b
}
object Double
val b = A.a
y Í
public object SomeClass {
    private val work = object : Runnable {
        override fun run() {
            foo()
        }
    }

    private fun foo(): Unit {
    }

    public fun run(): Unit = work.run()
}
object B
val b = A.a
xR
companion object {
        protected fun foo() = "OK"
    }
object B
val b = A.a
x0
object A {
val a = v2.b
}
object B
val b = A.a
x/
object A {
val a = B.b
}
object B
val A = A.a
x1
object A {
val a = B.b
}
object B
val b = A.max
x;
object A {
val a = sb.append(this)
}
object B
val b = A.a
x3
object A {
val a = E.ENTRY
}
object B
val b = A.a
x1
object A {
val a = inc.b
}
object B
val b = A.a
x@
object A {
const val M = Long.MIN_VALUE
}
object B
val b = A.a
x;
object A {
val a = N().C().test5()
}
object B
val b = A.a
x5
object A {
val a = B.b
}
object B
val b = println.a
y ˙
object A {
  operator fun Int.component1() = this + 1
  operator fun Int.component2() = this + 2

  fun doTest(): String {
      var s = ""
      for ((a, b) in 0.rangeTo(2)) {
        s += "$a:$b;"
      }
      return s
  }
}
object B
val b = A.a
x7
object A {
val a = B.b
}
object ByteArray
val b = A.a
xc
object A {
private val fld: String = "O"
        get() = { field }() + "K"
}
object B
val b = A.a
x5
object A {
val a = B.b
}
object B
val b = A.OHolder
x?
object A {
var order = StringBuilder()
}
object B
val b = A.a
x2
object A {
val a = B.b
}
object B
val b = A.test
x5
object A {
val a = B.b
}
object Request
val b = A.a
x4
object A {
val a = B.b
}
object B
val b = A.aShort
x;
object A {
val a = Local("K").fn()
}
object B
val b = A.a
x3
object A {
val a = value.b
}
object B
val b = A.a
x.
object A {
val a  B.b
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val b =A.a
x,
object A {
val a = B.b
}
object B
val b = 
x.
object A {
val a = .b
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val b= A.a
x.
object A {
val a = B.b
}
object B
val b = .a
x.
object A {
val  = B.b
}
object B
val b = A.a
x.object A {
val a = B.b
}
object B
val b = A.a
x.
object A {
val a = B.b}
object B
val b = A.a
x.
objectA {
val a = B.b
}
object B
val b = A.a
x.
object A {
val a = B.b
}object B
val b = A.a
x'
object A {
val a = B.b
}

val b = A.a
x.
object A {
vala = B.b
}
object B
val b = A.a
x)
object A {
val a = B.b
}
 B
val b = A.a
w

object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val b = Aa
x.
object A {
val a = B.
}
object B
val b = A.a
x)
 A {
val a = B.b
}
object B
val b = A.a
x.
object A {val a = B.b
}
object B
val b = A.a
x.
object A 
val a = B.b
}
object B
val b = A.a
x.
object A {
val a = B.b

object B
val b = A.a
x.
object A {
val a = B.b
}
object Bval b = A.a
x.
object A {
val a = B.b
}
object 
val b = A.a
x.
object A {
val a = B.b
}
object B
val b = A.ax.
object  {
val a = B.b
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val b  A.a
x.
object A{
val a = B.b
}
object B
val b = A.a
x$
object A {
val a = B.b
}
object B

x.
object A {
val a = Bb
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
valb = A.a
x.
object A {
val a= B.b
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val b = A.
x.
object A {
val a =B.b
}
object B
val b = A.a
x.
object A {
val a = B.b
}
object B
val  = A.a
x,
object A {
 a = B.b
}
object B
val b = A.a
x,
object A {
val a = 
}
object B
val b = A.a
x 
object A 
object B
val b = A.a
x,
object A {
val a = B.b
}
object B
 b = A.a
x.
object A {
val a = B.b
}
objectB
val b = A.a
x$
object A {

}
object B
val b = A.a
x%

val a = B.b
}
object B
val b = A.a
ˇˇ
øiexportTaggdefaultnoriginalSampley—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
gmutantsüyq// Original bug: KT-14628
// Duplicated bug: KT-14628


val v = false
if (v) {abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}} else {abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}}


// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}


val c = true
when (c) {
 true -> {// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}}
 else -> {// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}}
}

yˆ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<
val i = true
if (i) {TItem} else {TItem}
, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, 
val v = true
try
{TBuilder}
catch(e: Exception){}
finally{}
> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    
val o = true
try
{abstract inner class Builder {
        abstract fun append(item: TItem)
    }}
catch(e: Exception){}
finally{}

}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yì// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    
val p = false
if (p) {class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }} else {class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }}

}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: 
val n = false
if (n) {BaseClass<Byte, ImplForByte.ByteBuilder>} else {BaseClass<Byte, ImplForByte.ByteBuilder>}
() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        
val o = false
try
{abstract fun append(item: TItem)}
catch(e: Exception){}
finally{}

    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y=// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        
val t = false
if (t) {override fun append(item: Byte): Unit =
            TODO("not implemented")} else {override fun append(item: Byte): Unit =
            TODO("not implemented")}

    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: 
val y = false
try
{BaseClass<Byte, ImplForByte.ByteBuilder>.Builder}
catch(e: Exception){}
finally{}
() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            
val v = true
when (v) {
 true -> {TODO("not implemented")}
 else -> {TODO("not implemented")}
}

    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(
val h = false
try
{item: TItem}
catch(e: Exception){}
finally{}
)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y˚// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: 
val h = false
if (h) {BaseClass} else {BaseClass}
<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(
val d = false
try
{item: Byte}
catch(e: Exception){}
finally{}
): Unit =
            TODO("not implemented")
    }
}
y	// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            
val t = false
when (t) {
 true -> {TODO}
 else -> {TODO}
}
("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): 
val s = true
try
{Unit}
catch(e: Exception){}
finally{}
 =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.
val w = false
try
{Builder}
catch(e: Exception){}
finally{}
() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(
val t = false
when (t) {
 true -> {"not implemented"}
 else -> {"not implemented"}
}
)
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: 
val f = true
try
{TItem}
catch(e: Exception){}
finally{}
)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: 
val a = false
when (a) {
 true -> {BaseClass}
 else -> {BaseClass}
}
<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: 
val r = true
when (r) {
 true -> {Byte}
 else -> {Byte}
}
): Unit =
            TODO("not implemented")
    }
}
yı// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<
val h = true
if (h) {Byte} else {Byte}
, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.
val h = true
when (h) {
 true -> {ByteBuilder}
 else -> {ByteBuilder}
}
>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, 
val y = false
when (y) {
 true -> {ImplForByte}
 else -> {ImplForByte}
}
.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y	// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<
val s = false
when (s) {
 true -> {Byte}
 else -> {Byte}
}
, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¸// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.
val e = true
if (e) {ByteBuilder} else {ByteBuilder}
>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, 
val l = true
try
{ImplForByte}
catch(e: Exception){}
finally{}
.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yè// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        (override
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            (TODO("not implemented"))
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte!!.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: (BaseClass<Byte, ImplForByte.ByteBuilder>)?() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): (Unit)? =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: (BaseClass<Byte, ImplForByte.ByteBuilder>.Builder)?() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: (TItem)?)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: (Byte)?): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<(Byte)?, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (ImplForByte.ByteBuilder)?>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<(Byte)?, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, (ImplForByte.ByteBuilder)?>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>!!.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Byte {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Builder, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        { fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() abstract
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<ByteBuilder, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.TItem>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<("not implemented"), ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOByte
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder BaseClass
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: {<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    ( inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builderabstract) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override Unit append(item: Byte): fun =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: Byte)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<TItem, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>item: Byte) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append((): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder(item: Byte) BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append:: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
override fun append(item: Byte): Unit =
            TODO("not implemented") ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        object
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItemabstract fun append(item: TItem) TBuilder> {
    abstract inner class Builder {
        ,
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    // if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
} class Builder {
        abstract fun append(item: TItem)
    }
}

abstract inner
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: "not implemented".Builder() {
        override fun append(item: Byte): Unit =
            TODO(BaseClass<Byte, ImplForByte.ByteBuilder>)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Builder.ByteBuilder>.ImplForByte() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassitemByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(<: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassBaseClassTItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: <<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    ImplForByte
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, abstract inner class Builder {
        abstract fun append(item: TItem)
    }.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: )TItem
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

:

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem:
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder) BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: "() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(BaseClass<Byte, ImplForByte.ByteBuilder>not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.)>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented"ByteBuilder
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    BaseClass<Byte, ImplForByte.ByteBuilder> class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: abstract inner() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract not implemented BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("class")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    Byte class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<abstract inner, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> ,

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte{
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, item: Byte>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(ImplForByte.ByteBuilder): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassoverride fun append(item: Byte): Unit =
            TODO("not implemented").Builder() {
        <Byte, ImplForByte.ByteBuilder>
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.(>.BuilderByteBuilder) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>{) (
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.)(Builder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    } fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    abstract
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<item: Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    = inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit abstract
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<ImplForByte, Byte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> Byte

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> Byte
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<{, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: {() BaseClass<Byte, ImplForByte.ByteBuilder>
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>ImplForByte {
    class ByteBuilder: BaseClass<Byte, ().ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>. {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>()Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>BaseClass) {
    class ByteBuilder: (<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
( ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builderobject) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass().Builder<Byte, ImplForByte.ByteBuilder> {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(item: Byte) {
        override fun append(): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendTItemitem: ()
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<), ImplForByte.ByteBuilder>(Byte {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: ("not implemented")<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOBaseClass
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Builder<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.BaseClass() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte} BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
:
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: BaseClass<Byte, ImplForByte.ByteBuilder>)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TItem.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Byte() {
    class ByteBuilder: BaseClass<BaseClass<Byte, ImplForByte.ByteBuilder>, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, "> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implementedTBuilder)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        ImplForByte fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, abstract.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<("not implemented"), ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOByte
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<override fun append(item: Byte): Unit =
            TODO("not implemented"), ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        Byte
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ,<ByteBaseClass ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>Byte {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ()): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte= BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit :
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        : fun append(itemoverride Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TODO {
        override fun append(item: Byte): Unit =
            BaseClass<Byte, ImplForByte.ByteBuilder>.Builder()("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: <Byte, ImplForByte.ByteBuilder>)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassTItem.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: append {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun BaseClass<Byte, ImplForByte.ByteBuilder>()(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<TODO, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            Byte("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

TODO("not implemented")

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass"Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(<not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: item: Byte() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(BaseClass<Byte, ImplForByte.ByteBuilder>): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

{ class BaseClass<TItem, TBuilder> {
    abstract inner class Builder abstract
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderImplForByte {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, >.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    ByteBuilder
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.abstract inner class Builder {
        abstract fun append(item: TItem)
    }>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(=): Unit item: Byte
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    { class Builder abstract inner
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append=
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit (item: TItem)
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: BaseClass)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TItem<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    TODO ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            class("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        <
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassabstract fun append(item: TItem)Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
    {
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner Byte Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<class, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: ()
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendTItemitem: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassBaseClass<Byte, ImplForByte.ByteBuilder>.BuilderByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: <() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract ByteBuilder append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.fun>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>ByteBuilder) {
    class (: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<ImplForByte.ByteBuilder, Byte>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: () {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.BuilderBaseClass<Byte, ImplForByte.ByteBuilder>() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilderBaseClass<Byte, ImplForByte.ByteBuilder>.Builder :() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(TODO)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            item: TItem("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> ByteBuilder
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.{>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder append
        abstract fun {(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<BaseClass<Byte, ImplForByte.ByteBuilder>.Builder, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Byte() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, "not implemented">.Builder() {
        override fun append(item: Byte): Unit =
            TODO(ImplForByte.ByteBuilder)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<ImplForByte, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, TItem.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, .ImplForByteByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        ) fun append(item: TItemabstract
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TODO("not implemented"))
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TItem
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        (
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>abstract fun append(item: TItem)) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

" class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(abstractnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: "<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implementedBaseClass)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItemBaseClass<Byte, ImplForByte.ByteBuilder>
    }
}

// if I change to class here, all compiles well
object ImplForByte: )() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() TBuilder
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: : {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)BaseClass<Byte, ImplForByte.ByteBuilder>() Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        " fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(abstractnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    } class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() abstract inner
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: TODO {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            BaseClass<Byte, ImplForByte.ByteBuilder>()("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item} TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    :
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract not implemented class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("inner")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: .)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByteTItemByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass{TItem, TBuilder> <
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Unit.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): ImplForByte =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder{ {
    abstract inner class Builder >
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—<
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass// Original bug: KT-14628Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
{

abstract class BaseClass<TItem, TBuilder> // Duplicated bug: KT-14628
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (item: Byte)>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendImplForByte.ByteBuilder: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TODO> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TBuilder("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: Byte)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<TItem, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<{, ImplForByte.ByteBuilder>() Byte
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilderitem: Byte.Builder() {
        override fun append(>): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendUnit
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): (item: TItem) =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builderoverride {
        () fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, =>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit ImplForByte.ByteBuilder
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    not implemented inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("abstract")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilderByte() {
    class ByteBuilder: BaseClass<>, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder ImplForByte.ByteBuilder
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, {
        abstract fun append(item: TItem)
    }>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: (.BuilderBaseClass<Byte, ImplForByte.ByteBuilder>) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Byte.ByteBuilder>.Builder() {
        override fun append(item: ImplForByte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem(item: Byte)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass(item: Byte)Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append<: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }() BaseClass<Byte, ImplForByte.ByteBuilder>.Builder
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> :

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item{
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, BaseClass<Byte, ImplForByte.ByteBuilder>> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: TBuilder() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, }>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
ImplForByte.ByteBuilder
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class Byte<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<BaseClass, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.(item: Byte)>.Builder() {
        override fun appendByteBuilder: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.{>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() ByteBuilder
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() "
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented{)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: BaseClass<Byte, ImplForByte.ByteBuilder>)
    }
}

// if I change to class here, all compiles well
object ImplForByte: TItem() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override item: Byte append(fun): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    { class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() abstract inner
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ByteBuilder {
    class BaseClass<Byte, ImplForByte.ByteBuilder>(): BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: )(BaseClass<Byte, ImplForByte.ByteBuilder>.Builder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(itemByte :): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, "not implemented">() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(ImplForByte.ByteBuilder)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<>, ImplForByte.ByteBuilderByte() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

} class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
abstract

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendBuilder
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.(item: TItem)() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder. BaseClass<Byte, ImplForByte:ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderabstract fun append(item: TItem) {
    abstract inner class Builder {
        >
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner {
        abstract fun append(item: TItem)
    } Builder class
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: "() {
        override fun append(item: Byte): Unit =
            TODO("not implementedBaseClass<Byte, ImplForByte.ByteBuilder>.Builder)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.Unit>.Builder() {
        override fun append(item: Byte): ByteBuilder =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        ImplForByte fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, abstract.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Unit {
        override fun append(item: Byte): BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(itemBaseClass<Byte, ImplForByte.ByteBuilder>.Builder TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: :() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
// if I change to class here, all compiles well

}
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        TODO("not implemented")
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            abstract fun append(item: TItem)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract BaseClass append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: fun<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: ImplForByte)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, TItem.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class TItem<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: BaseClass)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: TODO<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            BaseClass("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass("not implemented")() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO<Byte, ImplForByte.ByteBuilder>
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassByte {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<<TItem, TBuilder>, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Byte>() {
    class ByteBuilder: BaseClass<ImplForByte.ByteBuilder, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> ImplForByte.ByteBuilder

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class class<TItem, TBuilder> {
    abstract inner BaseClass Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

ByteBuilder class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class abstract: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, override> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        TBuilder fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Unit.Builder() {
        override fun append(item: Byte): BaseClass<Byte, ImplForByte.ByteBuilder> =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder BaseClass<Byte, ImplForByte.ByteBuilder>
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: {() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun =(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit append
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: (<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendBaseClassitem: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<ByteImplForByte.ByteBuilder ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ,>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() <Byte, ImplForByte.ByteBuilder>
    class ByteBuilder: BaseClass{.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class ) {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(Builder {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Byte>.Builder() {
        override fun append(item: ImplForByte.ByteBuilder): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.:>.Builder() {
        override fun append(item: Byte)ByteBuilder Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder,() {
    class ByteBuilder: BaseClass<Byte> ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<(, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendTItemitem: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() BaseClass<Byte, ImplForByte.ByteBuilder>.Builder
    class ByteBuilder: {() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByteBaseClass<Byte, ImplForByte.ByteBuilder>.Builder BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: :() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, not implemented> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("TBuilder")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append({
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() item
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, override>.Builder() {
        ImplForByte.ByteBuilder fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassImplForByte {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, <TItem, TBuilder>.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ByteBuilder.ByteBuilder>() {
    class ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class {<TItem, TBuilder> {
    abstract inner class Builder BaseClass
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(})
    item: TItem
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

Byte

// if I change to class here, all compiles well
object ImplForByte: BaseClass<abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

item: TItem class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(abstract)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass"() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented<Byte, ImplForByte.ByteBuilder>)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<"not implemented", ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(Byte)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        ("not implemented") fun append(item: Byte): Unit =
            TODOoverride
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

{
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() // if I change to class here, all compiles well
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<>, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilderByte.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOImplForByte"not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

ImplForByte.ByteBuilder
object ImplForByte: BaseClass<Byte, // if I change to class here, all compiles well>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

"not implemented"
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(// if I change to class here, all compiles well)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        Byte fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<abstract, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() not implemented
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("{")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    BaseClass<Byte, ImplForByte.ByteBuilder>.Builder
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: abstract inner class Builder {
        abstract fun append(item: TItem)
    }() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            }("not implemented")
    TODO
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: override() {
        BaseClass<Byte, ImplForByte.ByteBuilder>.Builder fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

"
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(// if I change to class here, all compiles wellnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder("not implemented")) {
        override fun append(item: Byte): Unit =
            TODO(
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(")
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(item: TItemnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun Byte(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: append): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<(, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendByteitem: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, )> {
    abstract inner class Builder {
        abstract fun append(item: TItemTBuilder
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner TItem Builder {
        abstract fun append(item: class)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, (>.Builder() {
        override fun append(item: Byte): Unit =
            TODOImplForByte.ByteBuilder"not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, item>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(ImplForByte.ByteBuilder: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder(.Builder>) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (item: Byte).ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendImplForByte: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilderBaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
    class ByteBuilder: >() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Unit() {
        override fun append(item: Byte): BaseClass<Byte, ImplForByte.ByteBuilder>.Builder =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(")"not implemented
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem) TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte,: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

{ class BaseClass<TItem, TBuilder> abstract
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, override fun append(item: Byte): Unit =
            TODO("not implemented")>.Builder() {
        ImplForByte.ByteBuilder
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object Byte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<ImplForByte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class <<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassBaseClassByte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> override
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        { fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>ImplForByte.ByteBuilder) {
    class ByteBuilder: BaseClass<Byte, (>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: })
    TItem
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
}

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    // Duplicated bug: KT-14628
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        ImplForByte.ByteBuilder
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, abstract fun append(item: TItem)>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

Byte

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, ImplForByte> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, TBuilder.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Unit, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Byte =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class ImplForByte.ByteBuilder<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, BaseClass>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    TODO("not implemented") inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            abstract
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder())
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TItem {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        :
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)abstract fun append(item: TItem) Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, class> {
    abstract inner TBuilder Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}: TItem)
    }
}

item
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

. class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteabstractByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(BaseClass: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: item<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder ByteBuilder
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.{>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(itemfun TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override : append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<Unit, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): TItem =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassByte {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: <TItem, TBuilder>): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: , {
    class ByteBuilder: BaseClass<ByteBaseClass<Byte, ImplForByte.ByteBuilder>() ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append{item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() (
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class .<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteBaseClassByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
ImplForByte.ByteBuilder

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, }>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
Byte ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: object): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        item: Byte fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(abstract): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ByteBuilder<Byte, ImplForByte.BaseClass>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.TODO>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            ByteBuilder("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Byte>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ImplForByte.ByteBuilder): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>."not implemented"() {
        override fun append(item: Byte): Unit =
            TODO(Builder)
    }
}
y—// Original bug: KT-14628
ImplForByte

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, // Duplicated bug: KT-14628.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract class Builder {
        abstract inner fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    <Byte, ImplForByte.ByteBuilder>
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassabstract inner class Builder {
        abstract fun append(item: TItem)
    }() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class ImplForByte.ByteBuilder<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, BaseClass>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: =() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit BaseClass<Byte, ImplForByte.ByteBuilder>
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    TODO("not implemented")
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            }
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }>.Builder() ImplForByte.ByteBuilder
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, BaseClass<Byte, ImplForByte.ByteBuilder>> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TBuilder.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>BaseClass<Byte, ImplForByte.ByteBuilder>.Builder()) {
    class ByteBuilder: ( {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, BaseClass<Byte, ImplForByte.ByteBuilder>.Builder>() {
    class ByteBuilder: ImplForByte.ByteBuilder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<", ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(Bytenot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    TBuilder
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ByteBuilder.ImplForByte>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: =<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit BaseClass
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract override fun append(item: Byte): Unit =
            TODO("not implemented") class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        inner
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendImplForByte.ByteBuilderitem: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, (>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder :
}

// if I change to class here, all compiles well
object ImplForByte{
        abstract fun append(item: TItem)
    } BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassitem {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(<TItem, TBuilder>: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(": Byte): Unit =
            TODO(itemnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOImplForByte.ByteBuilder"not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassoverrideByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        < fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> item: TItem
    abstract inner class Builder {
        abstract fun append({)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, not implemented.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("ImplForByte")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

: class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByteabstract BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItemoverride
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        ) fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    ImplForByte
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, }.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        BaseClass<Byte, ImplForByte.ByteBuilder>.Builder()
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: abstract fun append(item: TItem) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
BaseClass<Byte, ImplForByte.ByteBuilder> ImplForByte: object() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract ImplForByte class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, inner.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    TODO class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            abstract inner("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilderBaseClass<Byte, ImplForByte.ByteBuilder>.Builder() : {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(): ByteBuilder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract // if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
} append(item: TItem)
    }
}

fun
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class TItem {
        abstract fun append(item: Builder)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object <: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassImplForByteByte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte"not implemented"ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(.)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.not implemented() {
        override fun append(item: Byte): Unit =
            TODO("Builder")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendUnit: (item: Byte) =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        BaseClass<Byte, ImplForByte.ByteBuilder>.Builder fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: abstract() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, =>.Builder() {
        override fun append(item: Byte): Unit ImplForByte.ByteBuilder
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, {.ByteBuilder>() ImplForByte
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner BaseClass<Byte, ImplForByte.ByteBuilder>.Builder Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: class() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    TODO("not implemented") ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            class
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<not implemented, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("Byte")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
})
    }
}

item: TItem
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<(item: Byte), ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendByte: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendnot implemented
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("(item: TItem)")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> Unit

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ("not implemented")<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOBaseClass
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, BaseClass<Byte, ImplForByte.ByteBuilder>.Builder.ByteBuilder>() {
    class ByteBuilder: ImplForByte() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(BaseClass: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: item<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

ImplForByte.ByteBuilder
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, // if I change to class here, all compiles well>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

Unit class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): abstract =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    item: Byte ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(class): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass)Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(< {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class { {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() Builder
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(Byte {
    class ByteBuilder: BaseClass<), ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ImplForByte() {
    class ByteBuilder: BaseClass<Byte, BaseClass<Byte, ImplForByte.ByteBuilder>.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendImplForByte.ByteBuilderitem: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder() BaseClass<Byte, ImplForByte.ByteBuilder>.Builder: {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte("not implemented") ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO,
    }
}
y—// Original bug: KT-14628
ImplForByte

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object // Duplicated bug: KT-14628: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): not implemented =
            TODO("Unit")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<ImplForByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Byte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder ()
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>{
        abstract fun append(item: TItem)
    } {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: override)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        TItem fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ("not implemented")): Unit =
            TODOByte
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract TODO("not implemented") append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            fun
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: :() {
        override fun append(item: Byte)BaseClass<Byte, ImplForByte.ByteBuilder>.Builder Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, BaseClass<Byte, ImplForByte.ByteBuilder>.Builder()> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TBuilder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, :.ByteBuilder>() {
    class ByteBuilderImplForByte BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder BaseClass<Byte, ImplForByte.ByteBuilder>.Builder
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: {() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<ImplForByte.ByteBuilder, Byte>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, :.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)ImplForByte Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Unit>.Builder() {
        override fun append(item: Byte): ImplForByte.ByteBuilder =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<), ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ByteByte: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<., TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteTItemByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<), TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(TItem {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem) TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented",
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder{
        abstract fun append(item: TItem)
    } {
    abstract inner class Builder >
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<append, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun TItem(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: }.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    BaseClass<Byte, ImplForByte.ByteBuilder>
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(} {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    )
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
)

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(} {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> BaseClass<Byte, ImplForByte.ByteBuilder>

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteappendByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun .(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(BaseClass<Byte, ImplForByte.ByteBuilder>.Builder {
    class ByteBuilder: )() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() Unit
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): { =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder.() {
    class ByteBuilder: BaseClass<Byte, ImplForByte>ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte{ ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() ,
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder ,
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte{ ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

: class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(itemabstract Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
ImplForByte ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, object.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        Byte fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: abstract): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<TODO("not implemented"), ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            Byte
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: .<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByteBaseClassByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override (item: Byte) appendfun: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun TODO(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            append("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, :.ByteBuilder>.Builder() {
        override fun append(item: Byte)ImplForByte Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

<Byte, ImplForByte.ByteBuilder>
object ImplForByte: BaseClass// if I change to class here, all compiles well() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    BaseClass<Byte, ImplForByte.ByteBuilder> class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: abstract inner.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteTODO("not implemented")ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            .
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun BaseClass(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: append<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

<Byte, ImplForByte.ByteBuilder> class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassabstract() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

()

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builderabstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append:
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)(item: TItem) Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<BaseClass<Byte, ImplForByte.ByteBuilder>, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Byte.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItemByte
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<), ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendnot implemented: Unit =
            TODO("(item: Byte)")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassByte<, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderinner {
    abstract > class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(BaseClass<Byte, ImplForByte.ByteBuilder>.Builder)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: item: TItem() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override "not implemented" append(item: Byte): Unit =
            TODO(fun)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, BaseClass.ByteBuilder>() {
    class ByteBuilder: ImplForByte<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItemByte
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: )): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: :)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilderTItem BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append"item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO((not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>.) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>(Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.)>.Builder(ByteBuilder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendByteBuilder
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class (item: TItem): BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(append {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun )(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class <Byte, ImplForByte.ByteBuilder> {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassBuilder.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendByteBuilderitem: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.(>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: :<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilderBaseClass BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderImplForByte.ByteBuilder {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, >>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ( {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOBaseClass<Byte, ImplForByte.ByteBuilder>()"not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
ImplForByte.ByteBuilder ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, object>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Byte.ByteBuilder>() {
    class ByteBuilder: BaseClass<ImplForByte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(itemImplForByte TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, :.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassBaseClass {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: <TItem, TBuilder><Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ><Byte, ImplForByte.ByteBuilderBaseClass() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
Byte

// if I change to class here, all compiles well
object ImplForByte: BaseClass<}, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    abstract fun append(item: TItem)
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun ImplForByte(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, append.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append())
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byteitem: TItem: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TODO)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TItem("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(Unit): item: Byte =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendTODO("not implemented"): Unit =
            (item: Byte)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        BaseClass<Byte, ImplForByte.ByteBuilder> fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: abstract() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    ImplForByte class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, abstract inner.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassByte() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: <Byte, ImplForByte.ByteBuilder>): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

class class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    abstract ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class =: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit ByteBuilder
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, "not implemented".ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(ImplForByte)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): TODO("not implemented") =
            Unit
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderBaseClass<Byte, ImplForByte.ByteBuilder>() {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: > {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun "(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(appendnot implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>: {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item() Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.<Byte, ImplForByte.ByteBuilder>>() {
    class ByteBuilder: BaseClassByteBuilder.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<}, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    Byte
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: .)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>TItemBuilder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassImplForByte.ByteBuilderByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, <>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass("not implemented") {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO<TItem, TBuilder>
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>class) {
    ( ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
})
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() TItem
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> Byte

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<{
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        "not implemented" fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(abstract)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Unit>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): ImplForByte.ByteBuilder =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, ByteBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.TBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    " inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implementedabstract)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

BaseClass

// if I change to class here, all compiles well
object ImplForByte: abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—Byte
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<// Original bug: KT-14628, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<Byte, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<TItem, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassImplForByte.ByteBuilder {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, <TItem, TBuilder>>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Byte<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: BaseClass): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, Byte> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<TBuilder, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
TItem

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: // Duplicated bug: KT-14628)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: (BaseClass<Byte, ImplForByte.ByteBuilder>) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }<Byte, ImplForByte.ByteBuilder>() {
    BaseClass
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<override, ImplForByte.ByteBuilder>.Builder() {
        Byte fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: {)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() TItem
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun Byte(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<append, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, }.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
ImplForByte
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        , fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byteabstract ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.>>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilderByteBuilder.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder ,
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte{
        abstract fun append(item: TItem)
    } ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassBaseClass<Byte, ImplForByte.ByteBuilder>.BuilderTItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: <() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
<TItem, TBuilder>

abstract class BaseClass// Duplicated bug: KT-14628 {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: :() {
        override fun append(itemBaseClass<Byte, ImplForByte.ByteBuilder>.Builder Byte): Unit =
            TODO("not implemented")
    }
}
y—Byte
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: // Original bug: KT-14628): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class abstract fun append(item: TItem) {
        Builder
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilderBaseClass {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ><Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilderoverride.Builder() {
        > fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appendImplForByteitem: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, (.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilderByte BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: :): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassfun() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override <Byte, ImplForByte.ByteBuilder> append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<BaseClass, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TItem<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(BaseClass)
    }
}

// if I change to class here, all compiles well
object ImplForByte: item: TItem<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(), TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: TItem {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class {
        abstract fun append(item: TItem)
    }<TItem, TBuilder> {
    abstract inner class Builder BaseClass
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    Byte ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: class): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassByteBuilder {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class <TItem, TBuilder>: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class :<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte)BaseClass Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun )(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented"append
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass>TItem, TBuilder< {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<"not implemented", ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO(Byte)
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder // if I change to class here, all compiles well
        abstract fun append(item: TItem)
    }
}

{
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }() {
    BaseClass<Byte, ImplForByte.ByteBuilder>
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

override

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Builder, ImplForByte.ByteBuilder>.Byte() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem} TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
,
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> )

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>({
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
} {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    {
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() abstract inner class Builder {
        abstract fun append(item: TItem)
    }
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ..ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByteImplForByteByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun ByteBuilder(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.append>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun override fun append(item: Byte): Unit =
            TODO("not implemented")(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        append
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append>
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder(item: TItem)() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<item, TBuilder> {
    abstract inner class Builder {
        abstract fun append(TItem: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: (item: Byte)() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appendBaseClass<Byte, ImplForByte.ByteBuilder>: Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object .: BaseClass<Byte, ImplForByteImplForByteByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item} Byte): Unit =
            TODO("not implemented")
    :
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append((: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODOitem"not implemented")
    }
}
y—<Byte, ImplForByte.ByteBuilder>
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass// Original bug: KT-14628.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() ByteBuilder
    class ByteBuilder: BaseClass<Byte, ImplForByte.{>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yª// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, T>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    operator class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, box> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y◊// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: changeLong): Unit =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            m(5)
    }
}
y5// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
    operator fun component1() = "O"
    operator fun component2(): String = throw RuntimeException("fail 0")
    operator fun component3() = "K"
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// KJS_WITH_FULL_RUNTIME

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): String =
            TODO("not implemented")
    }
}
y‹// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(a: Double?, b: Double): Unit =
            TODO("not implemented")
    }
}
y¡// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            A(Unit)
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<P : Any, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        fun box(): String {
    val ax: Boolean? = true
    val an: Boolean? = null
    val bx: Boolean = true
    val by: Boolean = false

    return when {
        nx != true -> "Fail 0"
        nx == false -> "Fail 1"
        !(nx == true) -> "Fail 2"
        !(nx != false) -> "Fail 3"
        nx != x -> "Fail 4"
        nx == y -> "Fail 5"
        !(nx == x) -> "Fail 6"
        !(nx != y) -> "Fail 7"
        nn == true -> "Fail 8"
        !(nn != true) -> "Fail 9"
        nn == x -> "Fail 10"
        !(nn != x) -> "Fail 11"
        ax != true -> "Fail 12"
        ax == false -> "Fail 13"
        !(ax == true) -> "Fail 14"
        !(ax != false) -> "Fail 15"
        ax != x -> "Fail 16"
        ax == y -> "Fail 17"
        !(ax == x) -> "Fail 18"
        !(ax != y) -> "Fail 19"
        ax != bx -> "Fail 20"
        ax == by -> "Fail 21"
        !(ax == bx) -> "Fail 22"
        !(ax != by) -> "Fail 23"
        an == true -> "Fail 24"
        !(an != true) -> "Fail 25"
        an == x -> "Fail 26"
        !(an != x) -> "Fail 27"
        an == bx -> "Fail 28"
        !(an != bx) -> "Fail 29"
        else -> "OK"
    }
}
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y™// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: T() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y©// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    override fun removeAt(x: Int) = "abc"
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: ss)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    override fun getValue(thisRef: Test, property: KProperty<*>) = "OK"
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Any() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: String<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‚// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    interface I<G> {
    fun <T> T.fromInterface(): T = this

    fun genericFromSuper(g: G) = g
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, private.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        public fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Boolean, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Test() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y√// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<T> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append()
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yØ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: String() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, String.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<z, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yƒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("OK")
    }
}
yΩ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Any>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.M>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

data class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun box(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            String("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<del, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, z> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y’// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class charArrayOf {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<*, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yß// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: String() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.size>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y„// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
    override fun toString() = "$firstName $lastName, age $age"
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y§// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder { }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: WithCompanion(this) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("$a:$b;")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<String, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≈// Original bug: KT-14628
// WITH_RUNTIME

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Double, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: String)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Int): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: b4<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y†// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: A {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, UInt>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yñ// Original bug: KT-14628
// Duplicated bug: KT-14628

enum class Season {
    WINTER,
    SPRING,
    SUMMER,
    AUTUMN
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, y> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yª// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, A>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<T, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class t: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Base>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y^// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

object Obj {
    var key = ""
    var value = ""

    operator fun set(k: String, v: ((String) -> Unit) -> Unit) {
        key += k
        v { value += it }
    }
}
y≈// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            published()
    }
}
y¿// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, String>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ArrayList>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y√// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<String, String?>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: String<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yø// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            run()
    }
}
yÿ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(desc: KProperty<*>)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y^// Original bug: KT-14628
// Duplicated bug: KT-14628

open class A

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            T("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.foo>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: T<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, a> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yß// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Result() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): x =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<*, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<()->Int, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y÷// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(parameters: Any?)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yµ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<*>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¿// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO()
    }
}
y◊// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(Comparable: Byte): Unit =
            TODO("not implemented")
    }
}
yN// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
    lateinit var p: String

    fun test(): Boolean {
        if (!::p.isInitialized) {
            p = "OK"
            return false
        }
        return true
    }
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        operator fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    lateinit class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yº// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    private var value: T? = null

    operator open fun getValue(thisRef: Any?, desc: KProperty<*>): T {
        if (value == null) {
            value = initializer()
        }
        return value!!
    }

    operator open fun setValue(thisRef: Any?, desc: KProperty<*>, svalue : T) {
        value = svalue
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: toByte<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: String): Unit =
            TODO("not implemented")
    }
}
yó// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    class G : T, U, A()
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(Test: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Test =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.z() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

class Delegate {
    var inner = 1
    operator fun getValue(t: Any?, p: KProperty<*>): Int = inner
    operator fun setValue(t: Any?, p: KProperty<*>, i: Int) { inner = i }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y˙// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
    val ChildInClass = object : Father.InClass() {
        override fun work(): String {
            return "OK"
        }
    }
}
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, set> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// TARGET_BACKEND: JVM

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<String, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            value("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, e.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.String() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y⁄// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<useScriptArgs, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.Int>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<box, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.b>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            myMap("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Box {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∑// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Array<List<*>>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.String>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            n("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun dd(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: foo)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yk// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class T(val f : () -> Any?) {
    fun call() : Any? = f()
}
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(x0: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    fun migrate(oldVersion: Long)
    {
        var _oldVersion = oldVersion

        if (4 > 3)
        {
            _oldVersion = 1
        }

        if (1 > 3)
        {
            _oldVersion++
        }
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

lateinit class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≠// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Long.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¢// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: A() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y®// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    val str: String
        get() = "OK"
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yú// Original bug: KT-14628
// Duplicated bug: KT-14628

inline class R(private val r: Int) {
    fun test() = runInline { "OK" }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Simple() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÆ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: B("OK") {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yΩ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Int>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¿// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, String>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("plus failed")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: Int)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): box =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Base>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Int<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class i<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<s, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∞// Original bug: KT-14628
// Duplicated bug: KT-14628

// See also KT-6299
public open class Outer private constructor() {
    class Inner: Outer()
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class box<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
    fun test() = foo()

    private companion object {
        private fun foo() = on { this }

        override fun toString() = "OK"
    }
}
}
y´// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    enum class Test {
    A,
    B,
    C
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y•// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Your() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<String>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≤// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yr// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class NoiseMaker {
    fun say(str: String) { sayResult += str }
}
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Byte? =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        override fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: s1<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ext): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: MyQueue<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<box, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<toInt, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y˜// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("Wrong elements for 5u.toUByte() downTo 5u.toUByte(): ")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, value.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yπ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<ULong>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("Fail 2")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Int =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: ArrayList<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun b(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yû// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        fun box() = R.test(R(0))
    }
}
y≈// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("123")
    }
}
yÈ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(null, value ?: return 1L) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Int.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Int<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.String>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            U("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.a>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, a.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// !LANGUAGE: +InlineClasses
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yπ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: GenericBase<Str>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: result<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, T> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yQ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    data class Box(var value: String)
}
y“// Original bug: KT-14628
// !LANGUAGE: +InlineClasses

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∞// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        fun test(p: T): T {
        return p
    }
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<IcInt, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<T, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: downTo)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÛ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Base("O" + if (i == 23) {
    log += "logged"
    "K"
}
else {
    "fail"
}) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: a<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y´// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: A(x) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y÷// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(p: KProperty<*>): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<UInt, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, with.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(): Unit =
            TODO("not implemented")
    }
}
yS// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    open class B<T, V> : A<T, Int, V>()
}
y›// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            MemberDescriptor("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

operator class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yΩ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Int>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<a, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y®// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: A<T, Int> {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<this, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, flusher.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.BoxFoo>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y_// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
  override fun equals(other: Any?): Boolean = false
}
yå// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        fun box(): String {
    val list = mutableListOf(3, 2, 4, 8, 1, 5)
    val expected = listOf(8, 5, 4, 3, 2, 1)
    list.sortWith(Comparator { a, b -> b - a })
    return if (list == expected) "OK" else list.toString()
}
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: length<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Int, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Z =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun A(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, b> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): A =
            TODO("not implemented")
    }
}
y˝// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        public fun box() : String {
    val a: A = AImpl()
    a.v
    return "OK"
}
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        open fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: list3<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y Û// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

private companion object {
        val result = "OK"
    }
yµ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<C>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<A, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∑// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Int>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y®// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
    val Long.foo: Long
        get() = this + 1

    val Int.foo: Int
        get() = this + 1

    fun testLong(): Long? {
        var s: Long? = 10;
        return s?.foo
    }

    fun testInt(): Int? {
        var s: Int? = 11;
        return s?.foo
    }
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class String: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŸ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): FooImplInner =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract class BaseGeneric<T>(val t: T) {
    abstract fun iterate()
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, Int.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yY// Original bug: KT-14628
// Duplicated bug: KT-14628

class A

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder("K") {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.UInt() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(i: Int)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Boolean, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, String.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: test3<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≠// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: B<String, V>() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        fun box(): String {
    var i = 0
    {
        if (1 == 1) {
            i++
        } else {
        }
    }()
    return "OK"
}
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

class My {
    lateinit var x: String
        private set

    fun init(arg: String, f: (String) -> String) { x = f(arg) }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<MyAlias, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun test(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‰// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(v: ((String) -> Unit) -> Unit): Unit =
            TODO("not implemented")
    }
}
y’// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: StringBuilder<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Base, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‹// with possible local optimizations
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yΩ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class Test {

    val property:Int
    init {
        fun local():Int {
            return 10;
        }
        property = local();
    }

}
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun z(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<r, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class a: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

in class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: p<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Array, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, Double.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<l, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y_// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    companion object {
        val value = 10
    }
}
yﬁ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): T = f()
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        f = { value }
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: test): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("fail3: ")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            S("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: nullValue<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y”// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(val y: String)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yõ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        private fun f() = "K"
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: ArrayList<String>(list) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            B("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun prop3(item: Byte): Unit =
            TODO("not implemented")
    }
}
y’// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(toString: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

object : SomeClass(3.14, 42, "No", "OK", "Yes") {
    }
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<reified T> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y’// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.updateOuter() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            a("not implemented")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    var f: Int

    init {
        var i = 10
        bar {
            i = 20
        }
        f = i + 1
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    override class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun get(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<T1, T2> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun IN(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≠// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Base() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("fail")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.Delegate>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yﬂ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        fun box(): String {
    return Test().test()
}
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.a() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): list4 =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            Int("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<test1, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yô// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    val s : String = "OK"
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// FILE: test.kt

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yy// Original bug: KT-14628
// Duplicated bug: KT-14628

class Foo {
    val a = test { this }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, memberProperty.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            sum("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, str.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y•// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Long() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class foo: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            Inner("not implemented")
    }
}
yÿ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<progression, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.AssertionError>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÆ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Inner() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    open class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.T>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: OK<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: Array<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class Int: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Host): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Kind =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Nested {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y⁄// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: AssertionError)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¨// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: Int() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<String>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yﬂ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
    class Inner: Outer("xyz")
    class Other: Outer("abc", true)
    class Another: Outer("", false)
}
}
y‘// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<() -> T, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: x)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class b: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¢// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: U() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// with possible local optimizations
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y√// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("O")
    }
}
y// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

object : Callback {
                override fun invoke() = FOO.x
            }
y// Auto-generated by GeneratePrimitiveVsObjectEqualityTestData. Do not edit!
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y«// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.i>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y√// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("i")
    }
}
yC// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    val prop: Int
    constructor(arg: Boolean) {
        if (arg) {
            prop = 1
            run2 { return }
            throw RuntimeException("fail 0")
        }
        prop = 2
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): B =
            TODO("not implemented")
    }
}
y◊// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): intArrayOf =
            TODO("not implemented")
    }
}
yﬁ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(message: String? = null): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<R, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y“// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Float, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, UInt>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yƒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    inline class A(val i: Int) {
    fun foo(s: String = "OK") = s
}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(x: String)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: A)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Any =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628


abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}
// Duplicated bug: KT-14628
// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
            TODO("not implemented")
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
    }
    }
}
y—// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

            TODO("not implemented")
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
// if I change to class here, all compiles well
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override  append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
objectImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner classBuilder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

 class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class <TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yƒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte):  =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yß// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte:  {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yŒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract  append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}yü// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder:  {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit=
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented)
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, >() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y√// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
     class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte):Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object : BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClassByte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: )
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, >.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: <Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y±// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun (item: Byte): Unit =
            TODO("not implemented")
    }
}
yæ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
 ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }}
yv// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() 
}
y|// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> 

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun appenditem: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem,TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yR// Original bug: KT-14628
// Duplicated bug: KT-14628



// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByteByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            ("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, .ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte) Unit =
            TODO("not implemented")
    }
}
yÀ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun (item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    classByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∏
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: <Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
     ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item:Byte): Unit =
            TODO("not implemented")
    }
}
y°// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: () {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
         fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte:BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
         fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO"not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder>{
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder> {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract  class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, .ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y π// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}


y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles wellobject ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, > {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")}
}
y©// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: () {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y0// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract funappend(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }

y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClassTItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y°// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder 
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y(// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() 
yÜ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        
    }
}
y∫// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            
    }
}
yƒ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∂// Original bug: KT-14628


abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>) {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract classBaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit 
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented"
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(: Byte): Unit =
            TODO("not implemented")
    }
}
y≈// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append: Unit =
            TODO("not implemented")
    }
}
y¬// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner  Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByteByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÕ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: ): Unit =
            TODO("not implemented")
    }
}
y…// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
     inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract  BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstractinner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract innerclass Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder( {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y¢// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}


object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun appenditem: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() 
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder(){
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        overridefun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override funappend(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder{
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y©// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: .Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder) {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yœ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte,ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÑ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>(){
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>( {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClassByte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstractclass BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstractfun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y∆// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class : BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() 
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte: Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÃ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)}
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte,ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y»// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y // Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class  {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder:BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder 
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }


// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y–// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
y≤// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass.Builder() {
        override fun append(item: Byte): Unit =
            TODO("not implemented")
    }
}
yÆ// Original bug: KT-14628
// Duplicated bug: KT-14628

abstract class BaseClass<TItem, TBuilder> {
    abstract inner class Builder {
        abstract fun append(item: TItem)
    }
}

// if I change to class here, all compiles well
object ImplForByte: BaseClass<Byte, ImplForByte.ByteBuilder>() {
    class ByteBuilder: BaseClass<Byte, ImplForByte.ByteBuilder>.Builder() {
        override fun append(item: Byte): Unit =

    }
}
ˇˇ
¿iexportTaggdefaultnoriginalSampleyŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
gmutantsŸy&// Original bug: KT-42787
// Duplicated bug: KT-32153


val m = true
if (m) {fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}} else {fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}

yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = 
val d = true
try
{sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}
catch(e: Exception){}
finally{}

yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <
val z = false
try
{K}
catch(e: Exception){}
finally{}
, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÀ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, 
val r = true
if (r) {V} else {V}
> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÛ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = 
val h = false
when (h) {
 true -> {sequence}
 else -> {sequence}
}
 {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> 
val v = true
when (v) {
 true -> {Map}
 else -> {Map}
}
<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÛ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): 
val j = false
when (j) {
 true -> {Sequence}
 else -> {Sequence}
}
<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yé// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence 
val c = false
when (c) {
 true -> {{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}
 else -> {{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}
}

yè// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence 
val o = true
when (o) {
 true -> {{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}
 else -> {{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}}
}

yÍ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    
val v = true
if (v) {suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)} else {suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)}

}
yª// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    
val u = false
if (u) {suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }} else {suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }}

    visit(this@toRecursiveSequence)
}
yñ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    
val a = true
when (a) {
 true -> {visit(this@toRecursiveSequence)}
 else -> {visit(this@toRecursiveSequence)}
}

}
yÀ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<
val w = true
if (w) {K} else {K}
, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÀ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, 
val s = true
if (s) {V} else {V}
>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yØ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.
val x = false
when (x) {
 true -> {Entry}
 else -> {Entry}
}
<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y|// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) 
val e = false
when (e) {
 true -> {{
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }}
 else -> {{
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }}
}

    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    
val l = false
try
{visit}
catch(e: Exception){}
finally{}
(this@toRecursiveSequence)
}
yÂ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<
val y = true
if (y) {Map} else {Map}
.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÎ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(
val y = false
if (y) {map: Map<K, V>} else {map: Map<K, V>}
) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yX// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        
val n = true
if (n) {map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }} else {map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }}

    }
    visit(this@toRecursiveSequence)
}
yà// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun 
val t = false
when (t) {
 true -> {SequenceScope}
 else -> {SequenceScope}
}
<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÝ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        
val e = true
when (e) {
 true -> {map.entries}
 else -> {map.entries}
}
.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.
val o = false
try
{forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }}
catch(e: Exception){}
finally{}

    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(
val z = false
try
{this@toRecursiveSequence}
catch(e: Exception){}
finally{}
)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        
val f = false
try
{map}
catch(e: Exception){}
finally{}
.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.
val n = false
try
{entries}
catch(e: Exception){}
finally{}
.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÙ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.
val m = true
when (m) {
 true -> {forEach}
 else -> {forEach}
}
 {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(
val k = true
try
{this}
catch(e: Exception){}
finally{}
@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<
val c = false
try
{K}
catch(e: Exception){}
finally{}
, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, 
val z = false
try
{V}
catch(e: Exception){}
finally{}
>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÃ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: 
val j = false
if (j) {Map} else {Map}
<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yE// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach 
val a = false
if (a) {{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }} else {{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }}

    }
    visit(this@toRecursiveSequence)
}
yÓ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this
val a = true
if (a) {@toRecursiveSequence} else {@toRecursiveSequence}
)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach 
val t = true
try
{{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }}
catch(e: Exception){}
finally{}

    }
    visit(this@toRecursiveSequence)
}
yÄ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.
val r = true
if (r) {Entry} else {Entry}
<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            
val m = true
try
{yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }}
catch(e: Exception){}
finally{}

        }
    }
    visit(this@toRecursiveSequence)
}
yÃ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<
val j = false
if (j) {Map} else {Map}
.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            
val y = true
try
{yield(it)}
catch(e: Exception){}
finally{}

            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y)// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            
val t = true
when (t) {
 true -> {if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }}
 else -> {if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }}
}

        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<
val m = true
try
{K}
catch(e: Exception){}
finally{}
, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÀ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, 
val e = true
if (e) {V} else {V}
>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y×// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            
val f = true
when (f) {
 true -> {yield}
 else -> {yield}
}
(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (
val o = true
try
{it.value is Map<*, *>}
catch(e: Exception){}
finally{}
) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) 
val j = true
when (j) {
 true -> {{
                visit(it.value as Map<K, V>)
            }}
 else -> {{
                visit(it.value as Map<K, V>)
            }}
}

        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<
val p = false
try
{K}
catch(e: Exception){}
finally{}
, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÀ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, 
val l = true
if (l) {V} else {V}
>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(
val o = false
try
{it}
catch(e: Exception){}
finally{}
)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÛ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (
val g = false
when (g) {
 true -> {it.value}
 else -> {it.value}
}
 is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÁ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value 
val q = true
if (q) {is} else {is}
 Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                
val b = false
try
{visit(it.value as Map<K, V>)}
catch(e: Exception){}
finally{}

            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (
val n = true
when (n) {
 true -> {it}
 else -> {it}
}
.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y×// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.
val y = true
when (y) {
 true -> {value}
 else -> {value}
}
 is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                
val m = true
try
{visit}
catch(e: Exception){}
finally{}
(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is 
val g = true
try
{Map}
catch(e: Exception){}
finally{}
<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(
val x = true
if (x) {it.value as Map<K, V>} else {it.value as Map<K, V>}
)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(
val s = true
try
{it.value}
catch(e: Exception){}
finally{}
 as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÕ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value 
val f = false
try
{as}
catch(e: Exception){}
finally{}
 Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(
val x = true
try
{it}
catch(e: Exception){}
finally{}
.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÄ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.
val j = true
if (j) {value} else {value}
 as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as 
val m = true
try
{Map}
catch(e: Exception){}
finally{}
<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÔ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<
val h = false
when (h) {
 true -> {K}
 else -> {K}
}
, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÁ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, 
val o = false
if (o) {V} else {V}
>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.(Entry)<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit((this@toRecursiveSequence))
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<(K), V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V!!> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V!!>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map!!.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries!!.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry!!<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }!!
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K!!, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V!!>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> (Map<K, V>)?.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): (Sequence<Map.Entry<K, V>>)? = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<(K)?, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, (V)?>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<(Map.Entry<K, V>)?> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun (SequenceScope<Map.Entry<K, V>>)?.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<(K)?, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, (V)?>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: (Map<K, V>)?) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<(Map.Entry<K, V>)?>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<(K)?, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, (V)?>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<(K)?, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, (V)?>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is (Map<*, *>)?) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as (Map<K, V>)?)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<(K)?, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, (V)?>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map!!.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<*.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, Map>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, *>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, V>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>map = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(>: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: {
                visit(it.value as Map<K, V>)
            }<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) Map
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopeMap<K, V>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as <Map.Entry<K, V>>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<(, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldKit)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence* = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<<Map.Entry<K, V>>, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V><*, *> {
        map.entries.forEach {
            yield(it)
            if (it.value is Map)) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<{, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) K
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence (
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit{this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence()( Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit:map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, VV> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, >>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: it.value is Map<*, *><K, V>) {
        map.entries.forEach {
            yield(it)
            if (Map) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): (it) = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldSequence<Map.Entry<K, V>>
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(itV
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, )>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, Map<K, V>>>.visit(map: V) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.<*, *> {
            yield(it)
            if (it.value is MapforEach) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            })
            it
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: ><K, VMap) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence>: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *()) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> map.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        Map<K, V>.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<:.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(mapMap Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<visit> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    Map.Entry<K, V>(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesyield(it)forEach {
            .
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K( V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit,this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.{<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach Entry
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<}.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            Map
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.it<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(Entry)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach visit
            yield(it)
            if (it.value is Map<*, *>) {
                {(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> sequence<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = Map {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    it fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(suspend.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<., V>>.visit(map: Map<K, V>) {
        map.entriesKforEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, this>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(V@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Map<*, *>>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is V) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(this@toRecursiveSequence)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(it)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Map.Entry<K, V>>> = sequence {
    suspend fun SequenceScope<V>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
        map.entries.forEach {
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<as> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value Map.Entry<K, V> Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
{

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach // Duplicated bug: KT-32153
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *)) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence>
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(Map: map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.is<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value Entry Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸthis
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(// Original bug: KT-42787@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>MaptoRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: .<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K. V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>,visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if visitit.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    ((this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence*Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<<, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): <<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapSequenceK, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K. V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map,entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<*, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<K, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}

// Duplicated bug: KT-32153
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>visit
            }
        }
    }
    )(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            (this@toRecursiveSequence) (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visitif
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence SequenceScope
    suspend fun {<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K<*, *> V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map,) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        {
                visit(it.value as Map<K, V>)
            }.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) map
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}.Entry<K, V>> = sequence Map
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): <<Map.EntrySequenceK, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(it.value as Map<K, V>: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(map)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, map: Map<K, V>>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(V) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            V
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): } = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    Sequence<Map.Entry<K, V>>
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

K <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<fun, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <map, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(K: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    // Duplicated bug: KT-32153
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K. V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it,value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield*
            if (it.value is Map<*, (it)>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<*, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<K, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, .> Map<K, V>VtoRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if ((.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visititthis@toRecursiveSequence)
}
yŸK
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<// Original bug: KT-42787, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            )(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>yield
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
} sequence
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): it<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Sequence.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<(map: Map<K, V>), V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visitK {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}>> = sequence V
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}>> = V
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(K: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<), V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.it {
            yield(it)
            if (forEach.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Ventries.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.>.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)<Map.Entry<K, V>> = sequence {
    Sequence
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<it>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(Map.Entry<K, V>)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it)value is Map<*, *>. {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, ,> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<KV V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) K
                visit(it.value as Map<{, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun <K, V><Map.Entry<K, V>>.visit(map: MapSequenceScope) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Mapthis@toRecursiveSequence.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(<K, V>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map(it)Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield.
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }>.visit(map: Map<K, V>) {
        map.entries.Map.Entry<K, V>
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<it, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (K.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)> = sequence {
    Map.Entry<K, V>
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<value>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.Map.Entry<K, V> as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<V.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Map>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

<Map.Entry<K, V>> <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopefun.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<V.Entry<K, Map>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, it.value is Map<*, *>>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (V) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
} = Sequence<Map.Entry<K, V>>
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is K<*, *>) {
                visit(it.value as Map<Map, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <it, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(K)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ>
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>// Original bug: KT-42787.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<:.Entry<K, V>>.visit(mapMap Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>suspendtoRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    . fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.)<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequenceEntry
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) (
                visit{it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(SequenceScope<Map.Entry<K, V>>: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun ).visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<V, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, K>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.Sequence<Map.Entry<K, V>>(): toRecursiveSequence = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.)
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<., V>.toRecursiveSequence(): Sequence<MapKEntry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, >>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *V) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopeKMap.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<<, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<Kit.value is Map<*, *> V>) {
        map.entries.forEach {
            yield(it)
            if (,) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            V(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, yield>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<it.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(Map)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, VK.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<>, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, @>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisVtoRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<V.Entry<K, Map>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Map>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: V<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(.: Sequence<Map)Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<@toRecursiveSequence.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisMap)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<}, V>)
            }
        K
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it(value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit.this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach (
            yield{it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): {<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) Sequence
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<visit(this@toRecursiveSequence)> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    Map.Entry<K, V>
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, VMap>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as ><K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<,K V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<this@toRecursiveSequence, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(K)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = SequenceScope {
    suspend fun sequence<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, K>>.visit(map: Map<V, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<,, V>.toRecursiveSequence(): Sequence<Map.Entry<KK V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesMapforEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as .<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}> = sequence <K, V>
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K) V>, {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<..Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesMapforEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>Kvisit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<., V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, visit(this@toRecursiveSequence)>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    V
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.this as Map<K, V>)
            }
        }
    }
    visit(value@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K{
                visit(it.value as Map<K, V>)
            } V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) ,
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapMapK, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is <<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<this, V>)
            }
        }
    }
    visit(K@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, yield>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            V(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K. V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries,forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) this@toRecursiveSequence
        }
    }
    visit({
                visit(it.value as Map<K, V>)
            })
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(K: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<map, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map*K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, <>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): > = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, VSequence<Map.Entry<K, V>>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, entries>) {
        map.V.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, VMap.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, toRecursiveSequence>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@V)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> K.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<Map<K, V>, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, )>)
            }
        }
    }
    visit(this@toRecursiveSequenceV
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(visit: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    )(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): V<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Sequence>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.* is Map<value, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Map<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Sequence<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.K<Entry, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<SequenceScope<Map.Entry<K, V>>.Entry<K, V>> = sequence {
    suspend fun Map.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: ,) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*Map<K, V> *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Mapit.valueEntry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(. as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

Map <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<fun.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<}, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            K
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(@toRecursiveSequence as Map<K, V>)
            }
        }
    }
    visit(thisit.value)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): it.value<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Sequence as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            Map.Entry<K, V>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    yield fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            suspend(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Mapvisit)
            }
        }
    }
    <K, V>(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): . = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(itSequence<Map.Entry<K, V>>value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> ..toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesMap<K, V>forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            <K, V>(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Mapyield)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<<K, V>.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.EntryMap>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, (>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if Vit.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.<(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MaptoRecursiveSequenceK, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach Map
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.V<K, V>>.visit(map: Map<K, Entry>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = <Map.Entry<K, V>> {
    suspend fun SequenceScopesequence.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V(.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if >it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, map>>.visit(map: Map<K, V>) {
        V.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MaptoRecursiveSequence) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@<K, V>)
}
yŸMap
// Duplicated bug: KT-32153

fun <K, V> // Original bug: KT-42787<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}.Entry<K, V>> = Map
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence it
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield({)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V() {
        map.entries.forEach {
            yield(it)
            if >it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is value<*, *>) {
                visit(it.Map as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<yield, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            K(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): < = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapSequence<Map.Entry<K, V>>K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.as is Map<*, *>) {
                visit(it.value value Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapMap<K, V>K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as <)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, >>.toRecursiveSequence(): Sequence<Map.Entry<K, VV> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<forEach, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.K {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>V {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, )>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, <K, V>>.toRecursiveSequence(): Sequence<Map.EntryV> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence V
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, {>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<*, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<K, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    : fun SequenceScope<Map.Entry<K, V>>.visit(mapsuspend Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        mapitentries.forEach {
            yield(it)
            if (..value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K} V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
,
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, {>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence V
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun isK, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value < Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, ()> Map<K, V>.toRecursiveSequenceV: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>it {
                visit().value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸV
// Duplicated bug: KT-32153

fun <K, // Original bug: KT-42787> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Map>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is V<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <<, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapKK, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>this@toRecursiveSequence {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit())
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> visit sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                =(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence*: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, ()>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, (>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visitVthis@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if thisit.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit((@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Map.Entry<K, V>>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<V>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = V {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, sequence>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.visit<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    Entry(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(this@toRecursiveSequence) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(map: Map<K, V>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = Map {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as sequence<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, it>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (V.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> SequenceScope<Map.Entry<K, V>>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun Map<K, V>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V@toRecursiveSequence Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<visit, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    K(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapK.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<<K, V>, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    K
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries,forEach {
            yield(it)
            if (it.value is Map<*. *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(itKvalue as Map<., V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> V sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, =>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<{
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) K
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, this@toRecursiveSequence>)
            }
        }
    }
    visit(V)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(itvalue. as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Entry, V>> = sequence {
    suspend fun SequenceScope<Map.K<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>@toRecursiveSequencetoRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this.)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun Entry<Map.SequenceScope<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.V {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, forEach>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapMapK, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as <<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <KK V> Map<,, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequencesuspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }Map.Entry<K, V>> = sequence {
    <
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<{.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach Map
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequenceV): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, (>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(V) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, map: Map<K, V>>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it., is Map<*, *>) {
                visit(it.value as Map<Kvalue V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.( as Map<K, V>)
            }
        }
    }
    visitvaluethis@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): }<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
Sequence
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (value.value is Map<*, *>) {
                visit(it.it as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<value> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.Map.Entry<K, V> is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, Map>) {
        map.entries.forEach {
            yield(it)
            if (it.value is V<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is )) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequenceMap<*, *>
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<,.Entry<KMap V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<Map<K, V>, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as K)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (}) {
                visit(it.value as Map<K, V>)
            it.value is Map<*, *>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, this>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(V@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceKMap.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<<, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            ( ifit.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceV = sequence {
    suspend fun SequenceScope<Map.Entry<K, <Map.Entry<K, V>>>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldKit)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<(, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (Map<*, *>.value is it) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<it.value as Map<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Map.Entry<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, K>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<V, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.it.value is Map<*, *><K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (Entry) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.(this@toRecursiveSequence)<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visitEntry
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> suspend.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    Map<K, V> fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

K <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<fun, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map.Entry<K, V>.toRecursiveSequence(): Sequence<Map<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K. V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>,visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<(, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visitKit.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<MapSequenceScopeEntry<K, V>> = sequence {
    suspend fun .<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is MaptoRecursiveSequence) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@<*, *>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence Map
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, it>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(V)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Map>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as V<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<V, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, K>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<{
                visit(it.value as Map<K, V>)
            }, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) K
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequenceK: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<(), V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit{
                visit(it.value as Map<K, V>)
            } {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) (map: Map<K, V>)
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<yield(it), V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            K
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

(it.value as Map<K, V>) <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visitfun
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.< is Map<*, *>) {
                visit(it.value as MapvalueK, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.V<K, Entry>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceMapMap.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: <<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Mapit.value as Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            K (it.value is Map<*, *>) {
                visit(it.value as Map<if, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend Map SequenceScope<fun.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence Map
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as {<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                it.value(visit as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapKK, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<<, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.value<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.Entry is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> map.entries sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        =.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence <
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map(map: Map<K, V>)Entry<K, V>>.visit. {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, VMap Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as ><K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, .>.toRecursiveSequence(): Sequence<MapVEntry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry(K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield<it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapSequence<Map.Entry<K, V>>.toRecursiveSequence(): <K, V> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entrysequence> = <K, V> {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, :>>.visit(mapV Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.K(map: Map<visit, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence()K Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<:, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequencevisit = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    <Map.Entry<K, V>>(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) it.value as Map<K, V>
                visit({)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<it> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(Map.Entry<K, V>)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<*.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, Map>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        @toRecursiveSequence.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thismap.entries)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.yield.forEach {
            entries(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence()V Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, :>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}<K, V>> = sequence Entry
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (Map<K, V> is Map<*, *>) {
                visit(it.value as it.value)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: it.value<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Map as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = {
                visit(it.value as Map<K, V>)
            } {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) sequence
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<{, V>) K
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is visit) {
                Map<*, *>(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.V<K, Entry>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map(entries.forEach {
            yield(it)
            if .it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.is value Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, it>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(V)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        it.forEach {
            yield(it)
            if (map.entries.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Map<K, V>>.visit(map: Entry<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<value, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.K is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<map, V>>.visit(K: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, }>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
V
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<), V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>K
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<if, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            K (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<)> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(itMap.Entry<K, V>
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit() as Map<K, V>it.value
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, K>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<V, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequencevisit): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    ((this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: is<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value Map Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    V fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, suspend>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: value) {
        map.entries.forEach {
            yield(it)
            if (it.Map<K, V> is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, K>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<V, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, *>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<V, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: }) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            Map<K, V>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Map<K, V>, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: K) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, Map>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as V<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<Map<K, V>, V>>.visit(map: K) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapVK, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, <>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <Map.Entry<K, V>, V> Map<K, V>.toRecursiveSequence(): Sequence<K> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, visit>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                V(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Map<K, V>>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as V)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.(.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visitentriesthis@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun >.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *SequenceScope<Map.Entry<K, V>>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, VMap>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is ><*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }, V>) {
        map.entries.forEach K
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, ,>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<KV V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.it.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(entries.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<it, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(K)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <KMap V> Map<K, V>.toRecursiveSequence(): Sequence<,.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>Map.Entry<K, V>toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<.>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(this)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(it@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) )
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence{
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Map.Entry<K, V>, V>.toRecursiveSequence(): Sequence<K> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Map<K, V>>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: V) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    } <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    fun
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (@.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisittoRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(this) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(map: Map<K, V>@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            .(it)
            if (it.value is Map<*, *>) {
                visit(ityieldvalue as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>thisvisit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(.@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<MapmapEntry<K, V>>.visit(map: Map<K, V>) {
        ..entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<sequence.Entry<K, V>> = Map {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> }<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            Map
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, {
                visit(it.value as Map<K, V>)
            }> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) V
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.><K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *Entry) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<@, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisKtoRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.K<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<Entry, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entryit> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(<K, V>)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }>> = sequence {
    V
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map.Entry<K, V><K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <it.value is Map<*, *>, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (K) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visitasit.value ( Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>V.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, >>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence}: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        ()
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<V, V>>.visit(map: Map<K, K>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun ><Map.Entry<K, V>>.visit(map: Map<K, VSequenceScope) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<as, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value K Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapsequenceK, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = < {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (itvaluevalue is Map<*, *>) {
                visit(it.. as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun ><Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *SequenceScope) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<V, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, K>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<visit.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                Map(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<(>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if Map.Entry<K, V>it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun :K, V> Map<K, V>.toRecursiveSequence()< Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Map.Entry<K, V>, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<K>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) )
        }
    }
    visit(this@toRecursiveSequence{
                visit(it.value as Map<K, V>)
            }
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.V<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Entry>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(Map<*, *>: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is )) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: value<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.Map is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.it.value(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(visit as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, value>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.V is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K( V>) {
        map.entries.forEach {
            yield(it)
            if ,it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)>> = sequence {
    V
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.EntryMap<K, V>>.visit(map: <K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map)Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>.
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        Entry
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> <.toRecursiveSequence(): Sequence<Map.EntryMap<K, V>K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence Map.Entry<K, V>
    suspend fun SequenceScope<{>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(K)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<it, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }, V>) {
        map.entries.K
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<).Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(itMap
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence>Map.Entry<K, V<> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}): Sequence<Map.Entry<K, V>> = sequence (
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> it<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Map.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸit
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (// Original bug: KT-42787.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceScope<Map.Entry<K, V>> = sequence {
    suspend fun Sequence<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Mapif (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            .
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visitit {
        map.entries.forEach {
            yield(it)
            if ((map: Map<K, V>).value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<{
                visit(it.value as Map<K, V>)
            }> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) Map.Entry<K, V>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Mapsuspend.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    <K, V> fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.as {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value forEach Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        (this@toRecursiveSequence)
    }
    visitmap.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<}> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            Map.Entry<K, V>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, )>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequenceV
}
yŸMap<*, *>
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is // Original bug: KT-42787) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (as) {
                visit(it.value it.value is Map<*, *> Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            V (it.value is Map<*, *>) {
                visit(it.value as Map<K, if>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    } fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) suspend
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.Map is value<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}, V>> = sequence K
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.yield<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            Entry(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, Map> Map<K, V>.toRecursiveSequence(): Sequence<V.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<SequenceScope, V>> = sequence {
    suspend fun K<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, is>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value V Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(K: Map<map, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<*>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, Map.Entry<K, V>>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> .<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        mapMapentries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.EntrytoRecursiveSequenceK, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@<)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, .>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(itVvalue as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K. V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it,value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence it.value is Map<*, *>
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if ({) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, <K, V>>>.visit(map: MapV) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<(it)> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldMap.Entry<K, V>
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<map, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        K.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<it.value is Map<*, *>, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (K) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }, V>) {
        K
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<this@toRecursiveSequence> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(Map.Entry<K, V>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapitK, V>) {
        map.entries.forEach {
            yield(<)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.K {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<forEach, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, Map<*, *>> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is V) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit( {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(map: Map<K, V>)this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        } fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach suspend
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, }>) {
                visit(it.value as Map<K, V>)
            }
        *
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }) {
        map.entries.Map<K, V>
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach K
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldit.valueit)
            if (( is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

K <fun, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopeKMap.Entry<<, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Mapvisit(this@toRecursiveSequence)) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    <K, V>
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun V Map<K, <K, V>>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<K> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<Map.Entry<K, V>, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<*> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<Map.Entry<K, V>, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> visit<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    Map(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V><K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach toRecursiveSequence
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, value>) {
        map.entries.forEach {
            yield(it)
            if (it.V is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequenceMap<K, V>): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as ()
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<it.value as Map<K, V>.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Map)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.visit as Map<K, V>)
            }
        }
    }
    value(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> ().toRecursiveSequenceMap<K, V>: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Map, V>.toRecursiveSequence(): Sequence<K.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
it.value

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (// Duplicated bug: KT-32153 is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<., V>KtoRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<., V>> = sequence {
    suspend fun SequenceScope<MapKEntry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        ,.entries.forEach {
            yield(it)
            if (it.value is Map<*map *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map)Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>. {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<entries.Entry<K, V>>.visit(map: Map<K, V>) {
        map.Map.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Map<K, V>.value as it)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach this
    }
    visit({
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }@toRecursiveSequence)
}
yŸV
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, // Original bug: KT-42787>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map*entries.forEach {
            yield(it)
            if (it.value is Map<., *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V><K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }.Entry<K, V>>.visit(map: Map<K, V>) {
        Map
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> {.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach Map<K, V>
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<), V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>K {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<V, K>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: (<K, V>) {
        map.entries.forEach {
            yield(it)
            if Mapit.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

V <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, fun>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun K<Map.Entry<SequenceScope, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Mapmap.entriesK, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        <.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Vvisit> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.>(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            } Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            <K, V>
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, it.value as Map<K, V>>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(V)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: map.entries) {
        Map<K, V>.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, Map>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is V<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, K>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<V, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<<.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is MapMap*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence.Map<Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>Vvisit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, .>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is as<*, *>) {
                visit(it.value Map Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }.entries.forEach map
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> as<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value Map Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Map, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as K<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): forEach<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.Sequence {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, {>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach V
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopeEntryMap.<<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
,

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K// Duplicated bug: KT-32153 V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, VK.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<>, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = * {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<sequence, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<V.Entry<K, V>>.visit(map: Map<K, Map>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is this) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(Map<*, *>@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, visit>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    V(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
} = sequence >
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceMap<.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<value, V>) {
        map.entries.forEach {
            yield(it)
            if (it.K is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, yield(it)>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            V
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend } SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
fun
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence Entry
    suspend fun SequenceScope<Map.{<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Mapvisit(this@toRecursiveSequence)K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    <
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map<K, V>.Entry<K, V>>.visit(map: Map) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesVforEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, .>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map{
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach .
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}, V>> = K
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<*> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, Map.Entry<K, V>>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, Vvisit(it.value as Map<K, V>) Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                >
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> @toRecursiveSequence<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisMap)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K> V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V,> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map{Entry<K, V>> = sequence .
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<*, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, K>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            K
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <sequence, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = K {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.EntryMapK, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is <<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>) = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it>
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence<: Sequence()Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        (this@toRecursiveSequence).entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visitmap
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(mapmap.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        } Map<K, V>) {
        :
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence K
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, }>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
V
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if ({.value is Map<*, *>) it
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(it)this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <>, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>K = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.*<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<Entry, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*K *>) {
                visit(it.value as Map<,, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<>.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, VMap)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): K = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<Sequence<Map.Entry<K, V>>, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.EntrytoRecursiveSequence> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@<K, V>)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> MapMap.Entry<K, V>K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<<>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<<K, V>, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapK) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<., V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entriesKforEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>,.visit(map: Map<K> V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): , = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*Sequence<Map.Entry<K, V>> *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<,.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<KMap V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapforEachK, V>) {
        map.entries.< {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence V
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence,): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K( V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.x as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, Int>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<String>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<String.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<reflect, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.s(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<UInt>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, xx>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Foo<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, step>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as String)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): A<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‘// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit() {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: test1<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‘// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<C>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<A.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yX// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
    val f = object {
        val a by del()
    }

    f.a
}
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<f3, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, test>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<String, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<String> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <T, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is String) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, v>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(-0.0, 0.0)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<Delegate, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, listOf>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as A<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): toLong<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y$// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach { it + 1 }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Long>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(MaxS: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, C>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<UInt, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Nothing = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, String>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ©// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    {
        return p
    }
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    {
    val f1 = Foo("OK")
    val f2 = Foo("OK")
    if (f1 != f2) return "Fail equals"
    if (f1.hashCode() != f2.hashCode()) return "Fail hashCode"
    if (f1.toString() != f2.toString() || f1.toString() != "Foo(s=OK)") return "Fail toString: $f1 $f2"

    return f1.s
}
}
y"// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
                return field
            }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(X.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<T>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y	// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        c.b
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value !! Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> String.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.kotlin.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.B as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { val r = { cl };  r() }
y‹// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(listOf(1))
}
y¬// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, ArrayList<Int>>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        MutableMap.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<remove, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y§// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, Exception>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        Double.Companion.MAX()
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, zero>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—//problem is here
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y•// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@TestClass)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K: Any, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Int>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun ArrayList<NullableInt>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y"// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.Box<Long>(2 * 3)
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.wrap2<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(i: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, Any?>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(w.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, String>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<A?, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: String<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.Foo as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¬// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, AssertionError> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(Int@toRecursiveSequence)
}
y­// Original bug: KT-42787
// !LANGUAGE: +NestedClassesInAnnotations

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.foo.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<Int, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<MyRange1, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, ULong>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, A>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<T, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, *>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, ()->Int>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<ULong>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Float.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as bar<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.MyNumber {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): String = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y…// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
    val zi = Z(42).Inner(Z(100))
    if (zi.xx != 42) throw AssertionError()
    if (zi.z.x != 100) throw AssertionError()

    return "OK"
}
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<String.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = B {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Char, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (sideEffect() is Nothing?) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<String, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            t(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Int.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun String.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y§// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<in String, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<String, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.Companion as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<Tr, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(a as T)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.Foo(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, String>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y”// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Int?> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            String(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Long)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            foo(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‹// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit("OK")
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Bar>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yƒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    A()
}
y$// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach { it.age }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Sign<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value = Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    arrayOf("a", "b", "c", "d")
}
y‘// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@Outer)
}
y”// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Long> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y§// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<KProperty, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Array<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, String>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¬// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (localFun().toString() is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<x, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<a.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<String, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (Outer.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        Reproduce().test()
    }
    visit(this@toRecursiveSequence)
}
y«// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (log.append("<init>") is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun Delegate<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¨// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(dest : Array<in String>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
    fun foo() = "OK"
    return (::foo)()
}
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<*, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y®// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, someSpecialValue>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, T> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: u2<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<A>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Boolean, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, y>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y}// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) return "3: log = \"$log\""
        }
    }
    visit(this@toRecursiveSequence)
}
yr// Original bug: KT-42787
// Duplicated bug: KT-32153

fun box(): String {
    val ax: Long? = 0L
    val an: Long? = null
    val bx: Long = 0L
    val by: Long = 1L

    return when {
        nx != 0L -> "Fail 0"
        nx == 1L -> "Fail 1"
        !(nx == 0L) -> "Fail 2"
        !(nx != 1L) -> "Fail 3"
        nx != x -> "Fail 4"
        nx == y -> "Fail 5"
        !(nx == x) -> "Fail 6"
        !(nx != y) -> "Fail 7"
        nn == 0L -> "Fail 8"
        !(nn != 0L) -> "Fail 9"
        nn == x -> "Fail 10"
        !(nn != x) -> "Fail 11"
        ax != 0L -> "Fail 12"
        ax == 1L -> "Fail 13"
        !(ax == 0L) -> "Fail 14"
        !(ax != 1L) -> "Fail 15"
        ax != x -> "Fail 16"
        ax == y -> "Fail 17"
        !(ax == x) -> "Fail 18"
        !(ax != y) -> "Fail 19"
        ax != bx -> "Fail 20"
        ax == by -> "Fail 21"
        !(ax == bx) -> "Fail 22"
        !(ax != by) -> "Fail 23"
        an == 0L -> "Fail 24"
        !(an != 0L) -> "Fail 25"
        an == x -> "Fail 26"
        !(an != x) -> "Fail 27"
        an == bx -> "Fail 28"
        !(an != bx) -> "Fail 29"
        else -> "OK"
    }
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Int>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(0.0 as Comparable<Any>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit('a')
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.list as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<result, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit()
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Derived, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<KFooQux, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<Any?, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.Int is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    list2(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = kotlin {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yˆ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(i)
}
yˆ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(0)
}
yŒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(12)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is this<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<foo, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y “// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { TODO() }
yi// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
        ::toString.name
        ::toString.name
        ::toString.name
    }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> s<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yg// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) "OK"
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (thisRef is Foo) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yˆ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(x)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<i.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(Bar.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is box<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Boolean)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y å// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    fun <T : Any, R> T.let(f: (T) -> R): R = f(this)
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit('e')
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yj// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            myLaunch {
                myDelay(period)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield()
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Data>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(A.B.C as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y Î// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
            a {
                text = item
            }
        }
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Outer) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y´// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, InlineNotNullReference> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (toString.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = log {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, listOf>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, B>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<UInt>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y Ä// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
        (A) {
            A.result = "OK"
        }
    }
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<T, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(a as MutableList<Any?>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is String<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Another<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, y>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(String.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(40)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        String.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.A(0)
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.box(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            foo()
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                ax(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, a>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yy// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) throw AssertionError()
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<bar, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(n.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Unit) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (a.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(Foo@toRecursiveSequence)
}
y‹// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(1)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <C, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y•// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun log<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: SF<S>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(fn: T.() -> String) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.A as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<MyString, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, String?>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<String>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, box>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value += Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, T>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(239.toLong())
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        get.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(result)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is f<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, x>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Int>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(OK.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.String.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (String.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, Int>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Long, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (xs !is Array<*>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <x, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): C = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    inline fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                A(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<Int, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    AssertionError()
}
y-// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach { (x, y) -> x + y }
    }
    visit(this@toRecursiveSequence)
}
xI// Original bug: KT-42787
// Duplicated bug: KT-32153

fun test() = ok()
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <T> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (result.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yƒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (booleanV !is Boolean?) return "fail: true !is Boolean?"
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value == Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        T.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (b.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.Base {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Float) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<unaryPlus.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¦// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (tableView.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<foo, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y§// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.StringBuilder is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y2// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        (3.toShort()..9.toShort() step 2).reversed()
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Unit?.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thisl@)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Set<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(a1@toRecursiveSequence)
}
y š// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {x -> x.toLong()}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <result, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.t {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y“// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun K<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(2.0)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y9// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
    val ax: Long? = 0L
    return if (ax != x) "Fail" else "OK"
}
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// !LANGUAGE: +InlineClasses

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Int<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŠ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    {
    loop@ for (color in arr) {
        when (color) {
            Color.RED -> return color
            Color.GREEN -> break@loop
            Color.BLUE -> if (arr.size == 1) return color else continue@loop
        }
    }
    return Color.GREEN
}
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit((index, x)) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<String>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@String)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Float>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        run.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<Int, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.String {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.shl is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(foo2.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<T>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { x(1) in list() }
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    n(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<UInt>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            (A::foo)(B())
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    override fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@Test)
}
y•// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<First> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y…// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        val result = ArrayWrapper<T>()
        result.contents.addAll(contents)
        result.contents.reverse()
        return result
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): test<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y„// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun Int.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Any.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    name(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.run<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, UInt>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, str>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, add>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<i, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŠ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit()
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(0.9999.toFloat())
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                Test(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<A<T, Int, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<String>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (x != 0.toChar()) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, reflect>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y?// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach { (x, y, z) -> x + y + z.toString() }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<y.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<a, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Byte.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.Test(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Char)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y‘// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<T>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value += Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<value, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y	// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
    return when {
        !lt(1.0F, 42.0F) -> "Fail 1 LT F"
        lt(42.0F, 1.0F) -> "Fail 2 LT F"

        !le(1.0F, 42.0F) -> "Fail 1 LE F"
        le(42.0F, 1.0F) -> "Fail 2 LE F"
        !le(1.0F, 1.0F) -> "Fail 3 LE F"

        !ge(42.0F, 1.0F) -> "Fail 1 GE F"
        ge(1.0F, 42.0F) -> "Fail 2 GE F"
        !ge(1.0F, 1.0F) -> "Fail 3 GE F"

        gt(1.0F, 42.0F) -> "Fail 1 GT F"
        !gt(42.0F, 1.0F) -> "Fail 2 GT F"

        !lt(1.0, 42.0) -> "Fail 1 LT D"
        lt(42.0, 1.0) -> "Fail 2 LT D"

        !le(1.0, 42.0) -> "Fail 1 LE D"
        le(42.0, 1.0) -> "Fail 2 LE D"
        !le(1.0, 1.0) -> "Fail 3 LE D"

        !ge(42.0, 1.0) -> "Fail 1 GE D"
        ge(1.0, 42.0) -> "Fail 2 GE D"
        !ge(1.0, 1.0) -> "Fail 3 GE D"

        gt(1.0, 42.0) -> "Fail 1 GT D"
        !gt(42.0, 1.0) -> "Fail 2 GT D"

        !lt(MINUS0F, PLUS0F) -> "Fail 1 LT +-0 F"
        lt(PLUS0F, MINUS0F) -> "Fail 2 LT +-0 F"

        !le(MINUS0F, PLUS0F) -> "Fail 1 LE +-0 F"
        le(PLUS0F, MINUS0F) -> "Fail 2 LE +-0 F"
        !le(MINUS0F, MINUS0F) -> "Fail 3 LE +-0 F"
        !le(PLUS0F, PLUS0F) -> "Fail 3 LE +-0 F"

        ge(MINUS0F, PLUS0F) -> "Fail 1 GE +-0 F"
        !ge(PLUS0F, MINUS0F) -> "Fail 2 GE +-0 F"
        !ge(MINUS0F, MINUS0F) -> "Fail 3 GE +-0 F"
        !ge(PLUS0F, PLUS0F) -> "Fail 3 GE +-0 F"

        gt(MINUS0F, PLUS0F) -> "Fail 1 GT +-0 F"
        !gt(PLUS0F, MINUS0F) -> "Fail 2 GT +-0 F"

        !lt(MINUS0D, PLUS0D) -> "Fail 1 LT +-0 D"
        lt(PLUS0D, MINUS0D) -> "Fail 2 LT +-0 D"

        !le(MINUS0D, PLUS0D) -> "Fail 1 LE +-0 D"
        le(PLUS0D, MINUS0D) -> "Fail 2 LE +-0 D"
        !le(MINUS0D, MINUS0D) -> "Fail 3 LE +-0 D"
        !le(PLUS0D, PLUS0D) -> "Fail 3 LE +-0 D"

        ge(MINUS0D, PLUS0D) -> "Fail 1 GE +-0 D"
        !ge(PLUS0D, MINUS0D) -> "Fail 2 GE +-0 D"
        !ge(MINUS0D, MINUS0D) -> "Fail 3 GE +-0 D"
        !ge(PLUS0D, PLUS0D) -> "Fail 3 GE +-0 D"

        gt(MINUS0D, PLUS0D) -> "Fail 1 GT +-0 D"
        !gt(PLUS0D, MINUS0D) -> "Fail 2 GT +-0 D"

        else -> "OK"
    }
}
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = Nested {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y •// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { it -> it }
y»// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
    val a = A(239)
    a.value = 42
    return if (a.value == 42) "OK" else "Fail 1"
}
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.i<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y£// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(toByte.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y“// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<this.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@getter)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, z>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y{// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (o.value != "ipsum") return "Fail 3: ${o.value}"
        }
    }
    visit(this@toRecursiveSequence)
}
y“// Original bug: KT-42787
// WITH_RUNTIME

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, Double>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@add)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                box(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.toShort()
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Int) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<String, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, T>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.test<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<String, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.UInt(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yÁ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield("Expected an exception to be thrown")
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, X>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¡// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<String>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: foo<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<String?>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¤// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, result>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y•// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun run<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { it.key + it.value }
y
ê// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
    // D = 1101 C = 1100
    // 6 = 0110 5 = 0101
    var iarg1: Int = 0xDC56DC56.toInt()
    var iarg2: Int = 0x65DC65DC
    var i1: Int? = iarg1 and iarg2
    var i2: Int? = iarg1 or  iarg2
    var i3: Int? = iarg1 xor iarg2
    var i4: Int? = iarg1.inv()
    var i5: Int? = iarg1 shl 16
    var i6: Int? = iarg1 shr 16
    var i7: Int? = iarg1 ushr 16

    if (i1 != 0x44544454.toInt()) return "fail: Int.and"
    if (i2 != 0xFDDEFDDE.toInt()) return "fail: Int.or"
    if (i3 != 0xB98AB98A.toInt()) return "fail: Int.xor"
    if (i4 != 0x23A923A9.toInt()) return "fail: Int.inv"
    if (i5 != 0xDC560000.toInt()) return "fail: Int.shl"
    if (i6 != 0xFFFFDC56.toInt()) return "fail: Int.shr"
    if (i7 != 0x0000DC56.toInt()) return "fail: Int.ushr"


    // TODO: Use long hex constants after KT-4749 is fixed
    var larg1: Long = (0xDC56DC56L shl 32) + 0xDC56DC56 // !!!!
    var larg2: Long = 0x65DC65DC65DC65DC
    var l1: Long? = larg1 and larg2
    var l2: Long? = larg1 or  larg2
    var l3: Long? = larg1 xor larg2
    var l4: Long? = larg1.inv()
    var l5: Long? = larg1 shl 32
    var l6: Long? = larg1 shr 32
    var l7: Long? = larg1 ushr 32
    
    if (l1 != 0x4454445444544454) return "fail: Long.and"
    if (l2 != (0xFDDEFDDEL shl 32) + 0xFDDEFDDE) return "fail: Long.or"
    if (l3 != (0xB98AB98AL shl 32) + 0xB98AB98A) return "fail: Long.xor"
    if (l4 != 0x23A923A923A923A9) return "fail: Long.inv"
    if (l5 != (0xDC56DC56L shl 32)/*!!!*/) return "fail: Long.shl"
    if (l6 != (0xFFFFFFFFL shl 32) + 0xDC56DC56) return "fail: Long.shr"
    if (l7 != (0x00000000L shl 32) + 0xDC56DC56.toLong()) return "fail: Long.ushr"

    var sarg1: Short = 0xDC56.toShort()
    var sarg2: Short = 0x65DC.toShort()
    var s1: Short? = sarg1 and sarg2
    var s2: Short? = sarg1 or  sarg2
    var s3: Short? = sarg1 xor sarg2
    var s4: Short? = sarg1.inv()

    if (s1 != 0x4454.toShort()) return "fail: Short.and"
    if (s2 != 0xFDDE.toShort()) return "fail: Short.or"
    if (s3 != 0xB98A.toShort()) return "fail: Short.xor"
    if (s4 != 0x23A9.toShort()) return "fail: Short.inv"

    var barg1: Byte = 0xDC.toByte()
    var barg2: Byte = 0x65.toByte()
    var b1: Byte? = barg1 and barg2
    var b2: Byte? = barg1 or  barg2
    var b3: Byte? = barg1 xor barg2
    var b4: Byte? = barg1.inv()

    if (b1 != 0x44.toByte()) return "fail: Byte.and"
    if (b2 != 0xFD.toByte()) return "fail: Byte.or"
    if (b3 != 0xB9.toByte()) return "fail: Byte.xor"
    if (b4 != 0x23.toByte()) return "fail: Byte.inv"

    return "OK"
}
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.Float as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<Y, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                toString()
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<Int>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        this.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, y>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (Foo.a != 1234) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.a<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y§// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<String, Any?>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, T>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, i> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¥// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(UInt.MIN_VALUE as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence { fld }
y // Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach { -1 }
    }
    visit(this@toRecursiveSequence)
}
y‹// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(2)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<Long>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<C.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.test<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.Test(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        foo.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y¢// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        Double.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŸ// Original bug: KT-42787


fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
// Duplicated bug: KT-32153yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                (it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, >) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>
            }
        }
    }
    visit(this@toRecursiveSequence)
}
x8// Original bug: KT-42787
// Duplicated bug: KT-32153


yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, >) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries. {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is <*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K,V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>){
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.EntryK, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, >>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, >)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, >.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ‰// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence 
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence: Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K,V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (itvalue is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach 
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    (this@toRecursiveSequence)
}
y €// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = 
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if(it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K,V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> =  {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }}
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<* *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun <Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        .entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K,V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, > Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y”// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        .forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V> {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŠ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if () {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, >> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun  Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.valueis Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
     fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun .visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            (it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): <Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: MapK, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value  Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŽ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yƒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): SequenceMap.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScopeMap.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yˆ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: <K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence 
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yH// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> <K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value isMap<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value asMap<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y2// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit( as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as )
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as <K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *> {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence{
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: ) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it. is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>>= sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŒ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        mapentries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y—// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if ( is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is ) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)}
        }
    }
    visit(this@toRecursiveSequence)
}
y†
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y„// Original bug: KT-42787


fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend funSequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach 
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<MapEntry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yieldit)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y›// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) 
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>){
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(thistoRecursiveSequence)
}
yž// Original bug: KT-42787// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> .toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<MapEntry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y’// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y™// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
             (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y˜// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map..forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yc// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) 
        }
    }
    visit(this@toRecursiveSequence)
}
y ‘// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*,*>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y†// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence():  = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(itvalue as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visitit.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }}
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŽ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)

yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it. as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yž// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yŽ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
yœ// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend  SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value  Map<K, V>)
            }
        }
    }
    visit(this@toRecursiveSequence)
}
y ö// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) 
    visit(this@toRecursiveSequence)
}
yš// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }
        }

    visit(this@toRecursiveSequence)
}
y–// Original bug: KT-42787
// Duplicated bug: KT-32153

fun <K, V> Map<K, V>.toRecursiveSequence(): Sequence<Map.Entry<K, V>> = sequence {
    suspend fun SequenceScope<Map.Entry<K, V>>.visit(map: Map<K, V>) {
        map.entries.forEach {
            yield(it)
            if (it.value is Map<*, *>) {
                visit(it.value as Map<K, V>)
            }

    }
    visit(this@toRecursiveSequence)
}
ÿÿ
¿iexportTaggdefaultnoriginalSampley(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
gmutantsŸy	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess


val f = true
if (f) {fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}} else {fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}}


private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}


val n = true
try
{private fun bye() { println("Bye!"); exitProcess(0) }}
catch(e: Exception){}
finally{}


private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yp// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }


val r = true
when (r) {
 true -> {private fun noop() {}}
 else -> {private fun noop() {}}
}


private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yˆ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}


val m = false
if (m) {private fun output(value: Any): () -> Unit = { println(value) }} else {private fun output(value: Any): () -> Unit = { println(value) }}


val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yh// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }


val e = true
if (e) {val WHITESPACE = "\\s".toRegex()} else {val WHITESPACE = "\\s".toRegex()}


fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()


val k = false
try
{fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}}
catch(e: Exception){}
finally{}


sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}


val l = false
try
{sealed class CalcInput}
catch(e: Exception){}
finally{}

object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput

val j = true
try
{object EmptyLine : CalcInput()}
catch(e: Exception){}
finally{}

data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yz// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()

val a = true
if (a) {data class SingleInt(val value: Int) : CalcInput()} else {data class SingleInt(val value: Int) : CalcInput()}

data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()

val q = false
try
{data class TwoInts(val first: Int, val second: Int) : CalcInput()}
catch(e: Exception){}
finally{}

object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()

val s = true
if (s) {object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}} else {object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}}

data class Unknown(val input: String) : CalcInput()
y{// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}

val a = true
if (a) {data class Unknown(val input: String) : CalcInput()} else {data class Unknown(val input: String) : CalcInput()}

y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package 
val c = false
try
{calculator}
catch(e: Exception){}
finally{}


import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() 
val w = true
when (w) {
 true -> {{
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}}
 else -> {{
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}}
}


private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() 
val i = false
when (i) {
 true -> {{ println("Bye!"); exitProcess(0) }}
 else -> {{ println("Bye!"); exitProcess(0) }}
}


private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yJ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() 
val e = true
if (e) {{}} else {{}}


private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yZ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = 
val h = true
if (h) {{ println(value) }} else {{ println(value) }}


val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = 
val p = true
try
{"\\s".toRegex()}
catch(e: Exception){}
finally{}


fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y
)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput 
val w = true
when (w) {
 true -> {{
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}}
 else -> {{
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}}
}


sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt
val d = false
try
{(val value: Int)}
catch(e: Exception){}
finally{}
 : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y}// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts
val a = false
when (a) {
 true -> {(val first: Int, val second: Int)}
 else -> {(val first: Int, val second: Int)}
}
 : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yo// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown
val z = false
when (z) {
 true -> {(val input: String)}
 else -> {(val input: String)}
}
 : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import 
val r = true
try
{java.io.InputStreamReader}
catch(e: Exception){}
finally{}

import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import 
val q = true
try
{kotlin.system.exitProcess}
catch(e: Exception){}
finally{}


fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  
val k = false
if (k) {InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }} else {InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}

}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { 
val x = true
try
{println("Bye!")}
catch(e: Exception){}
finally{}
; exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); 
val m = false
try
{exitProcess(0)}
catch(e: Exception){}
finally{}
 }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(
val o = true
try
{value: Any}
catch(e: Exception){}
finally{}
): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = 
val t = false
try
{{ println(value) }}
catch(e: Exception){}
finally{}


val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = 
val o = true
if (o) {"\\s"} else {"\\s"}
.toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".
val o = false
try
{toRegex()}
catch(e: Exception){}
finally{}


fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yg// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(
val d = true
when (d) {
 true -> {line: String}
 else -> {line: String}
}
): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  
val g = true
try
{val input = line.trim()}
catch(e: Exception){}
finally{}

  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y¶// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  
val j = false
if (j) {if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand} else {if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand}


  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yî// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  
val u = true
when (u) {
 true -> {input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }}
 else -> {input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }}
}


  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y_// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  
val e = false
when (e) {
 true -> {input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }}
 else -> {input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }}
}


  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  
val y = false
if (y) {return Unknown(line)} else {return Unknown(line)}

}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yh// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  
val d = false
if (d) {const val commandText = "/exit"} else {const val commandText = "/exit"}

}
data class Unknown(val input: String) : CalcInput()
yc// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import 
val d = false
when (d) {
 true -> {java.io}
 else -> {java.io}
}
.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yl// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.
val o = true
when (o) {
 true -> {InputStreamReader}
 else -> {InputStreamReader}
}

import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yi// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import 
val i = false
when (i) {
 true -> {kotlin.system}
 else -> {kotlin.system}
}
.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yT// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.
val t = false
if (t) {exitProcess} else {exitProcess}


fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yv// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  
val s = true
if (s) {InputStreamReader(System.`in`)
    .buffered()} else {InputStreamReader(System.`in`)
    .buffered()}

    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yß// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .
val j = true
when (j) {
 true -> {forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}
 else -> {forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}
}

}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { 
val x = true
try
{println}
catch(e: Exception){}
finally{}
("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); 
val r = true
when (r) {
 true -> {exitProcess}
 else -> {exitProcess}
}
(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { 
val w = true
try
{println(value)}
catch(e: Exception){}
finally{}
 }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".
val y = true
try
{toRegex}
catch(e: Exception){}
finally{}
()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yd// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): 
val r = true
when (r) {
 true -> {CalcInput}
 else -> {CalcInput}
}
 {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = 
val v = true
when (v) {
 true -> {line.trim()}
 else -> {line.trim()}
}

  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yo// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  
val w = false
when (w) {
 true -> {input.toIntOrNull()}
 else -> {input.toIntOrNull()}
}
 // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y“// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.
val d = false
if (d) {also {// parsing succeeded so return it
      return (SingleInt(it))
    }} else {also {// parsing succeeded so return it
      return (SingleInt(it))
    }}


  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ys// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  
val w = false
when (w) {
 true -> {input.split(WHITESPACE)}
 else -> {input.split(WHITESPACE)}
}
.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y4// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).
val r = false
if (r) {let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }} else {let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }}


  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yU// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return 
val z = true
if (z) {Unknown(line)} else {Unknown(line)}

}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : 
val o = true
try
{CalcInput}
catch(e: Exception){}
finally{}
()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yW// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(
val l = false
if (l) {val value: Int} else {val value: Int}
) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : 
val w = false
if (w) {CalcInput} else {CalcInput}
()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yV// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(
val o = true
if (o) {val first: Int} else {val first: Int}
, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yj// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, 
val u = true
when (u) {
 true -> {val second: Int}
 else -> {val second: Int}
}
) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : 
val b = false
if (b) {CalcInput} else {CalcInput}
()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : 
val n = true
try
{CalcInput}
catch(e: Exception){}
finally{}
() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yO// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = 
val e = true
if (e) {"/exit"} else {"/exit"}

}
data class Unknown(val input: String) : CalcInput()
ym// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(
val k = false
when (k) {
 true -> {val input: String}
 else -> {val input: String}
}
) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : 
val l = false
if (l) {CalcInput} else {CalcInput}
()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import 
val g = false
try
{java}
catch(e: Exception){}
finally{}
.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.
val n = true
when (n) {
 true -> {io}
 else -> {io}
}
.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import 
val d = false
try
{kotlin}
catch(e: Exception){}
finally{}
.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.
val t = true
if (t) {system} else {system}
.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yz// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  
val l = false
when (l) {
 true -> {InputStreamReader(System.`in`)}
 else -> {InputStreamReader(System.`in`)}
}

    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .
val w = false
when (w) {
 true -> {buffered()}
 else -> {buffered()}
}

    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yg// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .
val c = false
when (c) {
 true -> {forEachLine}
 else -> {forEachLine}
}
 { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { 
val n = true
try
{println(value)}
catch(e: Exception){}
finally{}
 }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = 
val g = false
when (g) {
 true -> {line}
 else -> {line}
}
.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yO// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.
val m = false
if (m) {trim()} else {trim()}

  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (
val m = false
try
{input.isBlank()}
catch(e: Exception){}
finally{}
)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    
val g = true
try
{return EmptyLine}
catch(e: Exception){}
finally{}

  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else 
val o = false
try
{if (input == ExitCommand.commandText)
    return ExitCommand}
catch(e: Exception){}
finally{}


  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  
val y = true
if (y) {input} else {input}
.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.
val x = true
try
{toIntOrNull()}
catch(e: Exception){}
finally{}
 // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.
val j = false
when (j) {
 true -> {also}
 else -> {also}
}
 {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  
val y = false
if (y) {input} else {input}
.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yl// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.
val g = true
when (g) {
 true -> {split(WHITESPACE)}
 else -> {split(WHITESPACE)}
}
.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).
val q = true
when (q) {
 true -> {let}
 else -> {let}
}
 { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yO// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return 
val w = true
if (w) {Unknown} else {Unknown}
(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ym// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  
val j = false
when (j) {
 true -> {InputStreamReader}
 else -> {InputStreamReader}
}
(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yQ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .
val y = false
if (y) {buffered} else {buffered}
()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yÀ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine 
val b = true
if (b) {{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }} else {{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}

}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println(
val l = true
when (l) {
 true -> {"Bye!"}
 else -> {"Bye!"}
}
); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(
val r = false
try
{0}
catch(e: Exception){}
finally{}
) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: 
val r = false
try
{Any}
catch(e: Exception){}
finally{}
): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> 
val m = false
try
{Unit}
catch(e: Exception){}
finally{}
 = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yb// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { 
val o = true
when (o) {
 true -> {println}
 else -> {println}
}
(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: 
val u = true
try
{String}
catch(e: Exception){}
finally{}
): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.
val q = false
when (q) {
 true -> {trim}
 else -> {trim}
}
()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (
val p = true
if (p) {input} else {input}
.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.
val p = false
when (p) {
 true -> {isBlank()}
 else -> {isBlank()}
}
)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yd// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return 
val x = true
when (x) {
 true -> {EmptyLine}
 else -> {EmptyLine}
}

  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.
val y = true
try
{toIntOrNull}
catch(e: Exception){}
finally{}
() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also 
val j = true
try
{{// parsing succeeded so return it
      return (SingleInt(it))
    }}
catch(e: Exception){}
finally{}


  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.
val i = false
if (i) {split} else {split}
(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let 
val s = false
try
{{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }}
catch(e: Exception){}
finally{}


  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yÁ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine 
val z = false
if (z) {{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }} else {{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}

}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.
val w = false
try
{isBlank}
catch(e: Exception){}
finally{}
())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y|// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (
val i = false
when (i) {
 true -> {input == ExitCommand.commandText}
 else -> {input == ExitCommand.commandText}
}
)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    
val r = false
try
{return ExitCommand}
catch(e: Exception){}
finally{}


  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also 
val t = true
when (t) {
 true -> {{// parsing succeeded so return it
      return (SingleInt(it))
    }}
 else -> {{// parsing succeeded so return it
      return (SingleInt(it))
    }}
}


  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let 
val d = true
if (d) {{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }} else {{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }}


  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(
val p = false
if (p) {line} else {line}
)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : 
val x = false
when (x) {
 true -> {CalcInput}
 else -> {CalcInput}
}
()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yK// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: 
val j = true
if (j) {Int} else {Int}
) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : 
val b = false
when (b) {
 true -> {CalcInput}
 else -> {CalcInput}
}
()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: 
val p = false
try
{Int}
catch(e: Exception){}
finally{}
, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: 
val x = false
try
{Int}
catch(e: Exception){}
finally{}
) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : 
val q = true
try
{CalcInput}
catch(e: Exception){}
finally{}
()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : 
val v = false
if (v) {CalcInput} else {CalcInput}
() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: 
val d = false
try
{String}
catch(e: Exception){}
finally{}
) : CalcInput()
yQ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : 
val e = true
if (e) {CalcInput} else {CalcInput}
()
yT// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(
val t = false
if (t) {System.`in`} else {System.`in`}
)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y¼// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      
val y = true
when (y) {
 true -> {val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()}
 else -> {val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()}
}

    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(
val u = true
if (u) {value} else {value}
) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (
val c = true
if (c) {input} else {input}
 == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yJ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input 
val g = true
if (g) {==} else {==}
 ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yr// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == 
val x = true
when (x) {
 true -> {ExitCommand.commandText}
 else -> {ExitCommand.commandText}
}
)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yg// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return 
val r = false
when (r) {
 true -> {ExitCommand}
 else -> {ExitCommand}
}


  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y†// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {
val v = true
if (v) {// parsing succeeded so return it
      return (SingleInt(it))} else {// parsing succeeded so return it
      return (SingleInt(it))}

    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(
val a = true
try
{WHITESPACE}
catch(e: Exception){}
finally{}
).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y0// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    
val p = false
when (p) {
 true -> {if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)}
 else -> {if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)}
}

  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yb// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(
val e = false
when (e) {
 true -> {System}
 else -> {System}
}
.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y_// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.
val s = true
when (s) {
 true -> {`in`}
 else -> {`in`}
}
)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { 
val v = false
when (v) {
 true -> {line}
 else -> {line}
}
 ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      
val v = true
try
{val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }}
catch(e: Exception){}
finally{}

      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yV// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      
val l = true
if (l) {continuation()} else {continuation()}

    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yS// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == 
val u = true
if (u) {ExitCommand} else {ExitCommand}
.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yS// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.
val w = true
if (w) {commandText} else {commandText}
)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y_// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      
val e = false
if (e) {return (SingleInt(it))} else {return (SingleInt(it))}

    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { 
val z = false
if (z) {words} else {words}
 ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yŠ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    
val q = false
when (q) {
 true -> {if (words.size > 2)
      return Unknown(line)}
 else -> {if (words.size > 2)
      return Unknown(line)}
}

    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    
val b = false
try
{val first = words.getOrNull(0)?.toInt()}
catch(e: Exception){}
finally{}

    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yp// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    
val l = true
if (l) {val second = words.getOrNull(1)?.toInt()} else {val second = words.getOrNull(1)?.toInt()}

    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    
val m = false
try
{if (first != null && second != null)
      return TwoInts(first, second)}
catch(e: Exception){}
finally{}

  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        
val g = false
when (g) {
 true -> {when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }}
 else -> {when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }}
}

      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yh// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      
val n = false
when (n) {
 true -> {continuation}
 else -> {continuation}
}
()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yX// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return 
val i = false
if (i) {(SingleInt(it))} else {(SingleInt(it))}

    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yd// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = 
val p = false
if (p) {words.getOrNull(0)?.toInt()} else {words.getOrNull(0)?.toInt()}

    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yv// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = 
val e = true
when (e) {
 true -> {words.getOrNull(1)?.toInt()}
 else -> {words.getOrNull(1)?.toInt()}
}

    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (
val w = false
try
{val input = parseInput(line)}
catch(e: Exception){}
finally{}
) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (
val i = true
try
{SingleInt(it)}
catch(e: Exception){}
finally{}
)
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yi// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (
val n = true
when (n) {
 true -> {words.size > 2}
 else -> {words.size > 2}
}
)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y\// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      
val m = true
if (m) {return Unknown(line)} else {return Unknown(line)}

    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ym// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = 
val y = true
when (y) {
 true -> {words.getOrNull(0)}
 else -> {words.getOrNull(0)}
}
?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yc// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.
val n = false
when (n) {
 true -> {toInt()}
 else -> {toInt()}
}

    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yn// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = 
val m = false
when (m) {
 true -> {words.getOrNull(1)}
 else -> {words.getOrNull(1)}
}
?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.
val p = false
try
{toInt()}
catch(e: Exception){}
finally{}

    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (
val z = true
try
{first != null && second != null}
catch(e: Exception){}
finally{}
)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      
val z = true
try
{return TwoInts(first, second)}
catch(e: Exception){}
finally{}

  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yY// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = 
val u = false
if (u) {parseInput(line)} else {parseInput(line)}
) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> 
val d = false
try
{::noop}
catch(e: Exception){}
finally{}

          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yn// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> 
val g = true
when (g) {
 true -> {output(input.value)}
 else -> {output(input.value)}
}

          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yk// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> 
val a = false
if (a) {output(input.first + input.second)} else {output(input.first + input.second)}

          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> 
val b = false
when (b) {
 true -> {::bye}
 else -> {::bye}
}

          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yz// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> 
val r = false
if (r) {output("Don't know what to do with input $input")} else {output("Don't know what to do with input $input")}

        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (
val m = true
try
{SingleInt}
catch(e: Exception){}
finally{}
(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (
val l = true
if (l) {words.size} else {words.size}
 > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size 
val g = false
when (g) {
 true -> {>}
 else -> {>}
}
 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yI// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 
val i = true
if (i) {2} else {2}
)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return 
val o = true
try
{Unknown(line)}
catch(e: Exception){}
finally{}

    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = 
val u = false
when (u) {
 true -> {words}
 else -> {words}
}
.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yU// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.
val s = false
if (s) {getOrNull(0)} else {getOrNull(0)}
?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.
val x = false
if (x) {toInt} else {toInt}
()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = 
val w = true
try
{words}
catch(e: Exception){}
finally{}
.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yg// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.
val i = true
when (i) {
 true -> {getOrNull(1)}
 else -> {getOrNull(1)}
}
?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.
val q = true
if (q) {toInt} else {toInt}
()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (
val o = true
try
{first != null}
catch(e: Exception){}
finally{}
 && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null 
val g = false
try
{&&}
catch(e: Exception){}
finally{}
 second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && 
val a = true
try
{second != null}
catch(e: Exception){}
finally{}
)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return 
val w = false
try
{TwoInts(first, second)}
catch(e: Exception){}
finally{}

  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = 
val l = false
try
{parseInput}
catch(e: Exception){}
finally{}
(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::
val j = false
if (j) {noop} else {noop}

          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> 
val b = true
when (b) {
 true -> {output}
 else -> {output}
}
(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> 
val h = true
when (h) {
 true -> {output}
 else -> {output}
}
(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::
val k = false
try
{bye}
catch(e: Exception){}
finally{}

          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> 
val o = true
when (o) {
 true -> {output}
 else -> {output}
}
("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (
val s = true
when (s) {
 true -> {words}
 else -> {words}
}
.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yL// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.
val r = true
if (r) {size} else {size}
 > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yO// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return 
val u = true
if (u) {Unknown} else {Unknown}
(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.
val a = false
when (a) {
 true -> {getOrNull}
 else -> {getOrNull}
}
(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yR// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.
val i = false
if (i) {getOrNull} else {getOrNull}
(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (
val e = true
if (e) {first} else {first}
 != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yK// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first 
val y = false
if (y) {!=} else {!=}
 null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != 
val l = false
if (l) {null} else {null}
 && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && 
val w = true
try
{second}
catch(e: Exception){}
finally{}
 != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yJ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second 
val w = true
if (w) {!=} else {!=}
 null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != 
val e = false
when (e) {
 true -> {null}
 else -> {null}
}
)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yb// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return 
val e = true
when (e) {
 true -> {TwoInts}
 else -> {TwoInts}
}
(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y_// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> 
val f = true
when (f) {
 true -> {Unit}
 else -> {Unit}
}
 =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yK// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(
val a = false
if (a) {it} else {it}
))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(
val n = false
try
{line}
catch(e: Exception){}
finally{}
)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is 
val k = false
when (k) {
 true -> {EmptyLine}
 else -> {EmptyLine}
}
 -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ye// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is 
val a = false
when (a) {
 true -> {SingleInt}
 else -> {SingleInt}
}
 -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(
val f = true
try
{input.value}
catch(e: Exception){}
finally{}
)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is 
val s = false
try
{TwoInts}
catch(e: Exception){}
finally{}
 -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yu// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(
val e = true
when (e) {
 true -> {input.first + input.second}
 else -> {input.first + input.second}
}
)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is 
val u = true
when (u) {
 true -> {ExitCommand}
 else -> {ExitCommand}
}
 -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yP// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is 
val j = false
if (j) {Unknown} else {Unknown}
 -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y„// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output(
val r = true
when (r) {
 true -> {"Don't know what to do with input $input"}
 else -> {"Don't know what to do with input $input"}
}
)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yL// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(
val r = true
if (r) {line} else {line}
)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(
val r = false
when (r) {
 true -> {0}
 else -> {0}
}
)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y\// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(
val g = true
when (g) {
 true -> {1}
 else -> {1}
}
)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(
val y = true
when (y) {
 true -> {first}
 else -> {first}
}
, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yO// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, 
val t = false
if (t) {second} else {second}
)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(
val m = true
try
{input}
catch(e: Exception){}
finally{}
.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.
val v = false
when (v) {
 true -> {value}
 else -> {value}
}
)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yS// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(
val p = true
if (p) {input.first} else {input.first}
 + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yJ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first 
val x = false
if (x) {+} else {+}
 input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y^// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + 
val n = false
try
{input.second}
catch(e: Exception){}
finally{}
)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y`// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(
val f = true
when (f) {
 true -> {input}
 else -> {input}
}
.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.
val z = false
when (z) {
 true -> {first}
 else -> {first}
}
 + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yM// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + 
val t = true
if (t) {input} else {input}
.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.
val d = true
if (d) {second} else {second}
)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yN// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $
val g = false
if (g) {input} else {input}
")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

(

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package (calculator)

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = ("\\s".toRegex())

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput ({
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
})

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import (java.io.InputStreamReader)
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output((value): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .(forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    })
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : (CalcInput)()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : (CalcInput)()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if ((words.size > 2))
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = (words.getOrNull(0))?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = (words).getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if ((first) != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is (SingleInt) -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is (TwoInts) -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }!!

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess!!

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess!!(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"!!
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine!! { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line!!.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand!!

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let!! { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered!!()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit!! = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }!!

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput!!()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int!!) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String!!) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input!! == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`!!)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)!!
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt!!()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size!! > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown!!(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull!!(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts!! -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input!!")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): (() -> Unit)? = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): (CalcInput)? {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: (Any)?): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> (Unit)? = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: (String)?): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : (CalcInput)?()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: (Int)?) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : (CalcInput)?()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: (Int)?, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: (Int)?) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : (CalcInput)?()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : (CalcInput)?() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: (String)?) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : (CalcInput)?()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: (() -> Unit)? =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> (Unit)? =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is (EmptyLine)? -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is (SingleInt)? -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is (TwoInts)? -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is (ExitCommand)? -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is (Unknown)? -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s"!!.toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE)!!.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin!!.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System!!.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand!!.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words!!.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null || second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first == null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input!!.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input!!.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y.// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output((input.first).plus(input.second))
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yV// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if ((input)?.equals(ExitCommand.commandText) ?: (ExitCommand.commandText === null))
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { 1("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(println)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is Unit -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> ExitCommand = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown)line(
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): const {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  CalcInput val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return (val first: Int, val second: Int)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoIntsUnknown(line) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> first
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(::bye, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  return Unknown(line).split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  input
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlinnullsystem.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != . && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import () -> Unit
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: java.io.InputStreamReader =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
CalcInput class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : data()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () ( Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output->value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && CalcInput)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : second != null() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> outputInt
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: ("Don't know what to do with input $input")) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $if (input == ExitCommand.commandText)
    return ExitCommand")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else input

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        return Unknown(line)
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      }
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    (val input: String)

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown} : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> { println("Bye!"); exitProcess(0) } =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() Unit

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = val input: String.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(words) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() let

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).{
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
} { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
line

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(// Duplicated bug: KT-17018)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          words
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (is ExitCommand -> ::bye.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

input
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(import java.io.InputStreamReader.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input{ println(value) }value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = .

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output({ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  })
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let input.value

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "(val value: Int)s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt\\ : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (object ExitCommand : CalcInput() {
  const val commandText = "/exit"
})
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
input == ExitCommand.commandText
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "inputs".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (\\ == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("words.getOrNull(1)"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = Bye!?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { && ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null words second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderCalcInput()
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : (System.`in`)
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .private { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

forEachLine fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: output("Don't know what to do with input $input")) -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> (
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  CalcInput
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : // Try to parse two ints, returning Unknown if there are more than 2 words()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.first(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(split, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(inputval value: Intfirst + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(.) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() Int}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: {, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcessreturn }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    (0) ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(( + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noopinput.first) {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object CalcInput : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : EmptyLine()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit ()
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt=
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: )) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput(Int
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also CalcInput()

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : {// parsing succeeded so return it
      return (SingleInt(it))
    }
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!.); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input"split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

(

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleIntimport java.io.InputStreamReader
import kotlin.system.exitProcessit))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  private fun bye() { println("Bye!"); exitProcess(0) }
}

InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(CalcInput) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : 0() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.val?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, getOrNull(1) second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      /exit()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "continuation"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (( == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInputinput)
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(Systemalso`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.. {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .bufferedCalcInput()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : ()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output())
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0"Don't know what to do with input $input" }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    =forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input . line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      parseInput continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun val(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = )
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it)line.trim()
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() )

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE{ println("Bye!"); exitProcess(0) }.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknownsecondline)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, ()
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.private)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

second fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if ())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2input.isBlank()
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return (SingleInt(it))

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return ExitCommand
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

CalcInput fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : private()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { {
  const val commandText = "/exit"
} }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() println(value)
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = // Try to parse two ints, returning Unknown if there are more than 2 words(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  parseInput
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = wordsSingleIntgetOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class .(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import commandText.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val kotlin = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          return EmptyLine -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    is SingleInt
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): toInt -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.()()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun ()() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noopmain {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() (line)

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown{ println("Bye!"); exitProcess(0) }
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output}
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {(input.value)

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line0
    val first = words.getOrNull())?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::(
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if noopinput == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::()
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNullbye // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(CalcInput, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : first() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> return Unknown(line) =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  Unit
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class CalcInput(val value: Int) : SingleInt()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader}System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    (
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

(SingleInt(it))

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(val WHITESPACE = "\\s".toRegex())) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

line

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?./exit()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "toInt"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import javaTwoIntsio.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return .(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          also
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.is EmptyLine -> ::noop {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  "/exit"(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = InputStreamReader
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(().first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInputinput
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
CalcInput()

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : // Duplicated bug: KT-17018 {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + ()
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { printlninput.secondvalue) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

fun fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

private parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  } output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  ->

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)"/exit"toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = ?.
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

val fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

private WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  } {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let ()

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput(:
data class TwoInts(val first: Int, val second) Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(inputsizefirst + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.. > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
() -> Unit kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): import = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input}first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) .

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: Unknown(line) =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return () -> Unit
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

:

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine val WHITESPACE = "\\s".toRegex() CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed CalcInput CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : class()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput}) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {(line)

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(valuefirst != null && second != null Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (:)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          words -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { is Unknown ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(return Unknown(line))) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      line
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $return (SingleInt(it))")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      input
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import (val first: Int, val second: Int).system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoIntskotlin : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else (val first: Int, val second: Int)

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoIntsif (input == ExitCommand.commandText)
    return ExitCommand : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(2).let { words ->
    if (words.size > WHITESPACE)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package CalcInput()

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : calculator
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is private fun output(value: Any): () -> Unit = { println(value) } -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

EmptyLine

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(CalcInput)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : line()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (class.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data words Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first ) input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any+: () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      words
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation() ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : val value: Int()
data class SingleInt(CalcInput) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          {// parsing succeeded so return it
      return (SingleInt(it))
    } -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also is TwoInts

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is return -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      TwoInts TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $String")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: input) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!")&& exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null ; second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is CalcInput -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : ExitCommand()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.private.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

system fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(input)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (line.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.object EmptyLine : CalcInput() + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
first
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine output("Don't know what to do with input $input") line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> {
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println(input); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val "Bye!": String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      Bye!()
    }
}

private fun bye() { println("continuation"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .{ println(value) } { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = forEachLine

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    SingleInt
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class val first = words.getOrNull(0)?.toInt()(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (() {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNullval input = parseInput(line)1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
input

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  // Duplicated bug: KT-17018.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInputwords.getOrNull(1)?.toInt()line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = (
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull((val value: Int) // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    () EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInputreturn
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(bye)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::System.`in`
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .TwoInts()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class buffered(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          ExitCommand -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is is EmptyLine -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != nullInt
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: )) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        println("Bye!") (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { when; exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first ) input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput(+
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.first != null()
    if (toInt && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(Int)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: 1) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + println.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { input(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    )forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput(.
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)() {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput)
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull)1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput((
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(private)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

input.value fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::trim
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.bye()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput::line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> (bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() println(value)

private fun noop() {}

private fun output(value: Any): () -> Unit = { { println("Bye!"); exitProcess(0) } }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(val)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(0 input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.null.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != system && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("line$input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = Don't know what to do with input .trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(SystemWHITESPACE`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(.).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

object EmptyLine : CalcInput()
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
import java.io.InputStreamReader
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  return TwoInts(first, second).split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      input
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (object)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
words.size > 2 EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderCalcInputSystem.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : (()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java(SingleInt(it))io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return .
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(input.first + input.second)line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      "()
    }
}

private fun bye() { println("Bye!continuation); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() 2
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > // try to parse the whole line as a single int)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

(

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trimprivate fun bye() { println("Bye!"); exitProcess(0) })
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output(CalcInputDon't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class "
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  ,
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Intreturn Unknown(line) val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

2

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > private fun noop() {})
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is ) -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation(TwoInts
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) /exit
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "{"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (return) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  val input = parseInput(line) Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) second
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.{)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(return Unknown(line).first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      input
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> null =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != Unit && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is first -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (SingleInt != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(inputCalcInputvalue)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : .()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = object(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
parseInput EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknowninput
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val (line): String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = ExitCommand.commandText println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == {)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s"(val first: Int, val second: Int)toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts. : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          toInt() TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.is
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: EmptyLine): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object Any : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation// parsing succeeded so return it () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {:
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts((, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknownfirstval input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> WHITESPACE = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(Unit).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun CalcInput() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : main()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

Unit fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> private = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

(val input: String) calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknownpackage : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  val

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(} input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (null)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != input.isBlank() && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

()

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInputprivate fun output(value: Any): () -> Unit = { println(value) }
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleIntobjectval value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
( ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (=) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input val input = parseInput(line) line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(second)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.line)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  trim

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> TwoInts
          is output(input.value) -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInputval input = line.trim(): CalcInput {
  (line: String)
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.CalcInput.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : system()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    value
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val return EmptyLine: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: )): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt(String
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun outputCalcInputvalue: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : (()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is const val commandText = "/exit" -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  Unknown
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader({ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }.`in`)
    .buffered()
    .forEachLine System
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

CalcInput

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : private fun noop() {}()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else (val input: String)

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknownif (input == ExitCommand.commandText)
    return ExitCommand : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == SingleInt.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class ExitCommand(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlinoutputsystem.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> .("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $inputwords.size > 2)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (")
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  } main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let fun

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("toInt$input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.Don't know what to do with input ()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { input("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  println.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

data class Unknown(val input: String) : CalcInput() fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
private
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).if (words.size > 2)
      return Unknown(line) { words ->
    let
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first CalcInput input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : +()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) toIntOrNull()

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.} // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::words.getOrNull(1)?.toInt()
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = bye
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          return Unknown(line) -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      is TwoInts
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          exitProcess(0) Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); is }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)it {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt()))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(Any)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: input.first + input.second): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(&&).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null WHITESPACE second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size Unknown(line) 2)
      return >
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun byeline: String) { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput((): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.Any)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: second): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(isBlank + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.input.first())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + words.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = input.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = if (first != null && second != null)
      return TwoInts(first, second)

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    "\\s".toRegex()
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> ) = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2Unit
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"(value); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { printlnExitCommandvalue) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return (

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && CalcInput() != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : second
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return (
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toIntEmptyLine)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is && -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null EmptyLine second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  .(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE)InputStreamReaderlet { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun nooptoInt) {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.(()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val const = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  WHITESPACE val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: CalcInput() -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : ()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation) () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): (: -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (val)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(input.isBlank() value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system)exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): (. -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderinput.split(WHITESPACE)System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  (.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val ) = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim(input
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(value: Any)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(input.first + input.second): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is line -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(SingleInt: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand ExitCommand ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ->.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System:`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine . CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.object EmptyLine : CalcInput())
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
second
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else // parsing succeeded so return it

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {if (input == ExitCommand.commandText)
    return ExitCommand
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!")) exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText;
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(null))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != it)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is -> -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words EmptyLine
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.data(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
getOrNull class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          2 SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > is)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.words)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { second ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

fun

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

private fun noop() {} parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() toInt()

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.{
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.splitdataWHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
( class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt({
  const val commandText = "/exit"
}))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() it
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) line

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = }.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: Unknown): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return String(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(input) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val 0 = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.{ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let isBlank

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }(WHITESPACE).split

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

input main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(fun.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        } { line ->

      forEachLine
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    CalcInput
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class if (words.size > 2)
      return Unknown(line)
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = Int.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: words) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
input.first

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(import kotlin.system.exitProcess + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(;)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!")input.value exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\second != null".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && s)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(inputinput.first + input.secondvalue)
          is TwoInts -> output(.)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input String parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: =): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

toInt()

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.private fun noop() {}
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          Unknown -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return is TwoInts(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  ::noop(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> InputStreamReader
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.words.size > 2()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (trim)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

1

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(package calculator)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (CalcInput)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : input.isBlank()()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (CalcInput)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : first != null && second != null() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.CalcInput?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : getOrNull(1)()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is 0 -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(Unknown) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"return Unknown(line); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      )
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun return EmptyLine(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    output
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output("Don't know what to do with input $input")
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output(input.value)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) "
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println({Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      SingleInt()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class continuation(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> outputdata class Unknown(val input: String) : CalcInput()
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
(input.first + input.second)
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(())
    val first = words.getOrNull(0)?.toIntline
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $/exit")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "input"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package Unit

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> calculator = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText"/exit"
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = )
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      it
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if ((first, second))
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoIntsinput.isBlank()
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(CalcInput)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : line()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

input.value calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(package)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.data class Unknown(val input: String) : CalcInput()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
toInt()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .line
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(buffered())) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(line.trim().first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = input
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = ( println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown{line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(inputcontinuation()first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      .
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye({
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
} { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput )

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(()) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNullline1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  CalcInput(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : InputStreamReader()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine )
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (CalcInput(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : SingleInt()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: data class TwoInts(val first: Int, val second: Int) : CalcInput() -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          ( EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noopis) {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() (line) println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown{
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is != -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second ExitCommand null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          return TwoInts(first, second) EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      is
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(CalcInput.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : input()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

) calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, secondpackage
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is val -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, Unknown second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> {(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() output println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine (val input: String) line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown{ : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .first != null && second != null()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (buffered)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() ExitCommand

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == { println("Bye!"); exitProcess(0) }.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s"lettoRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).. { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> (noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput::)
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = (line).trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknownline
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          Int
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: is TwoInts -> output(input.first + input.second)) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

data
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
import java.io.InputStreamReader class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.==)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input `in` ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> ) = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, secondUnit
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      )()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2continuation
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() :

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value{ println("Bye!"); exitProcess(0) } Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); CalcInput }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): exitProcess(0) {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.= > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second size words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    })
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.value

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      }
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
return (SingleInt(it))
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is 0 -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(EmptyLine) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val CalcInput: Int) : second()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun mainoutput) {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> ((input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput CalcInput

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      value()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val continuation: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(linegetOrNull) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.)(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(line)it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
toInt()

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.import kotlin.system.exitProcess
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.println

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { exitProcess(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: data): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
Any class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (exitProcess input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); val(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> ()
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNulloutput("Don't know what to do with input $input") // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlankval second = words.getOrNull(1)?.toInt())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    ()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is val input: String -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(ExitCommand) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          null -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != is SingleInt && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      first != null && second != null
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (continuation())
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    input
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (} == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.it)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(second))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.getOrNull.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.system(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): (!= -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first ) null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine /exit
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "{ line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText(value)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInputisBlank()) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.(line))
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin."Bye!".exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println(system); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.val first: Int.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(split(WHITESPACE), val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> noop =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun Unit() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("first"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(Bye!, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt second output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && -> != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNullsize) // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.( > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.ioIntInputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: .) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> >(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size output 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val :: Int, val secondfirst Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size 1 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(>)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(line: String)0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(: CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

words.size > 2 java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (import)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(()) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInputline)
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderUnknownSystem.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class ((val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(line: String.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(System): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.println(value))
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { second }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); ( }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoIntsexitProcess(0)first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object return ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::CalcInput
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : bye() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          String
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: is TwoInts -> output(input.first + input.second)) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: (line)): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return UnknownAny
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        exitProcess(0) (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); when }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = 2(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > parseInput)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader{System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput (
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    (val input: String)buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown. : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $val")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(input first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  data // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
input.toIntOrNull() class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.null(1)?.toInt()
    if (first != null && second != getOrNull)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.))
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it)`in`
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.ExitCommand.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == system.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is ExitCommand -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == Unknown.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          0 -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(is ExitCommand) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .(
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNullforEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> } = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  Unit

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = ).trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput(line {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(bye.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun System() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation)(
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() private fun output(value: Any): () -> Unit = { println(value) }
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

{

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\parseInput".toRegex()

fun s(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          ExitCommand.commandText -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == is ExitCommand)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .input { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + forEachLine.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  (.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInputinput)
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + ).second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it)input
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.String.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: system): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let val value: Int

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt({ words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    IntforEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: ., val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    words
    val first = if (words.size > 2)
      return Unknown(line).getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0() }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {CalcInput

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : }()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is val second: Int -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, TwoInts) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (val value: Int == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(input) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(): Any): () -> Unit = { println(valuevalue }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is CalcInput -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): ExitCommand {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is ( -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if SingleIntfirst != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuationif (input == ExitCommand.commandText)
    return ExitCommand () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else :

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value= }

val WHITESPACE ) "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (CalcInput() != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : first
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(continuation)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      System.`in`()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input /exit parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "="
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
"

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input// Duplicated bug: KT-17018)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String)) CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it):
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import .
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = wordsjava.io.InputStreamReadergetOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun outputCalcInput()value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : (
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()()
    val second = words.getOrNull(1)?.toInt
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != () && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInputnull
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.null.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != system)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is () -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun byeTwoInts { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

ExitCommand

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(lineif (words.size > 2)
      return Unknown(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    )
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderconst
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  (System.`in`) val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import javaisio.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          . ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderCalcInputSystem.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): ( {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    )

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt(}
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(linewords.getOrNull(0)
    val first = )?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second Int null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: !=) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import ).io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim(java
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  (
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoIntsreturn Unknown(line)val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.Unknown)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return value(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : object
CalcInput() ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { CalcInput(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : println()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.String)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: value): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import getOrNull(1)
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.java.io.InputStreamReader?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  EmptyLine
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    } : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
)
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput(data class TwoInts(val first: Int, val second: Int) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered(continuation()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      )
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        second
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        } = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> outputCalcInput()
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : (input.first + input.second)
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + Unknown.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return input(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(first != null && second != null) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (0)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
private kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

import fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.CalcInput
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : InputStreamReader()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any)getOrNull(0) () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.:?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(return TwoInts(first, second))) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      line
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.return() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      toIntOrNull TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return invokeOnA(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : Foo()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: A, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> Nested("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : A()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : Father()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { s: String ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

operator fun Array<String>.set(index1: Int, index2: Int, elem: String) {
    this[index1 + index2] = elem
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.Obj)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(o.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (list3 != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): C = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : Outer()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yI// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(var value: T = null as T, var text: String? = null) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return "OK"
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(0)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $Long")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : T()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.InlineTrait()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): UInt = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: String) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { result(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(arg1)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { () ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val B: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is result -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  T(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.res()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return InClass(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// KJS_WITH_FULL_RUNTIME
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import your.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.Wrapper + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> result(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $A")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.String()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size in 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val foo: Any.() -> Unit = {}) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, String)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("OK"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val i: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (String != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("1$input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt("abc")
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yŸ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  o1?.length

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): String = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return "Fail 1: $test1"
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split().let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ys// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {
  val s = doTest()
  return if (s == "1:2;2:3;3:4;") "OK" else "fail: $s"
}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (B.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yò// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else "fail"

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = A.Nested(42)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ys// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (call = Z("Z").test(b = {res += "K"; "K"}(), c = {res += "L"; "L"}, a = {res+="O"; "O"}()))
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(A("O").a("K").v + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y:// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(values()[0].name + Variants.values()[1].name)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.foo(ic) // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { ArrayList<Long>() }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(a: Double?): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { Int(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Char): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : Boolean() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: my, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { p: T ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> Boolean("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : B()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yñ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      {
    test(1, 1, { it })
    return "OK"
}
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: index1) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + foo.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  A.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(baz)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { () ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .value { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (result.contents)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(0)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is s -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = "1".someProperty?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yi// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : Base("O" + if (i == 23) {
    log += "logged"
    "K"
}
else {
    "fail"
})
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class R(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput("x")) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.on
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { r ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.String()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = exit.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\ns".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(s.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).x { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.list3)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: myEnum) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(1) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (B().s > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import Any.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(123)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts() : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.eqIF {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ya// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    {
        return "Wrong elements for (MaxC - 2)..MaxC step 2: $list5"
    }

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { assertEquals(o === Long.Companion, true) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y9// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { {
    log += "logged"
    "K"
} }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(1))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val param: String, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val Foo: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object topLevel : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

open fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is ArrayList<*> -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(a.iterator())
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return A()
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = value.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (0.toByte())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == String.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is String -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown("OK")
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (A != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(t) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {{
    val u = Template()
    u.test()
    return if(u.collected.size == 1 && u.collected.get(0) == "239") "OK" else "fail"
}
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y
'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

fun testR0xE0() {
    // with possible local optimizations
    if ((-1).toByte() in 1L until 3L != range0.contains((-1).toByte())) throw AssertionError()
    if ((-1).toByte() !in 1L until 3L != !range0.contains((-1).toByte())) throw AssertionError()
    if (!((-1).toByte() in 1L until 3L) != !range0.contains((-1).toByte())) throw AssertionError()
    if (!((-1).toByte() !in 1L until 3L) != range0.contains((-1).toByte())) throw AssertionError()
    // no local optimizations
    if (element0 in 1L until 3L != range0.contains(element0)) throw AssertionError()
    if (element0 !in 1L until 3L != !range0.contains(element0)) throw AssertionError()
    if (!(element0 in 1L until 3L) != !range0.contains(element0)) throw AssertionError()
    if (!(element0 !in 1L until 3L) != range0.contains(element0)) throw AssertionError()
}

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          1 -> {}
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.box()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (Z1(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(x: Int): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.f()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun Test(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> Int("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .String()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : A()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y:// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.UninitializedPropertyAccessException

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is msg -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val z = Z().test()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "OK"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == toByte.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.String

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : append()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          !doChain("123") -> "failed 7"
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val Outer = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import 2.toByte()
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object Number : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (unboxedString != "sample") return "fail 2"
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> t =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  Any(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val desc = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown()
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val AssertionError: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.i()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(x: Int): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yw// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

fun box() : String {
    val (a, b) = A()

    fun run(): Int {
        return a
    }
    return if (run() == 1 && b == 2) "OK" else "fail"
}

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.M()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  foo(2, "239")
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yÍ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    {
    val x: CharSequence = ""
    val klass = x::class
    return if (klass == String::class) "OK" else "Fail: $klass"
}
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return Bad
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.b()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is Result.Failure -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".foo { it + 1 }

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (Unit.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.bar(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y6// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.mapOf("1"         to "OK")?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yÎ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine {
            i = 20
        }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val c = C.create()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getFromCompanion(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y£// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  s?.anyLength()

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y2// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toHasMap(hashMap)
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yG// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { ok }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y.// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(Bar("Fail"), second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is String -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess() }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(a, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).String { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (A() as? B)
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y0// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun linkedMapOf() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess("c") }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
private class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  this.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// KJS_WITH_FULL_RUNTIME
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : Test()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return localMethod(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return b

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (a3 as UInt?)
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yB// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  "".bar(40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, u = 20, v = 19,
                           w = 18, x = 17, y = 16, z = 15, aa = 14, bb = 13, cc = 12, dd = 11, ee = 10, ff = 9, gg = 8, hh = 7, ii = 6,
                           jj = 5, kk = 4, ll = 3, mm = 2, nn = 1).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : Int() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.reflect.KProperty

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, bar0)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yñ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if(A(myArray) == A(intArrayOf(0, 1, 2))) return "fail"

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yA// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation(-123456789123.toLong(), 0)
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts()
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : String()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).b { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = x(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> MaxI =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .B { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(AssertionError).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> i =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : ULong()
y3// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (ss == "0:a;1:b;2:c;3:d;" && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { a, b -> b - a }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(x))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return IntArray(0)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (result != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y=// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun d() = d

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: A =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// !LANGUAGE: +InlineClasses
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts("propValue4", second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val u: Int) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = array?.get(0)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { Child("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = AssertionError.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return "fail 6"
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : Comparable<T>()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import value.toString().InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : E1() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is k -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(String) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Base(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object x : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: StringBuilder) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { withIndex(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      list4()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> test1("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { (x: Int) ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(Char)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return String
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt() : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): String {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

operator fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is foo -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val box = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\O".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".String()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return this
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (t !is First)
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y;// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(c = {invokeOrder += "L"; "L"}).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : x()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is listOf -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y~// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  outer2.A2(123)
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(i)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (true || throw RuntimeException())
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> range1("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : l() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 111)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: A) : CalcInput()
yò// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else "Fail"

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(2)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return msg
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package String

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\"s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val Baz: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

operator fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yd// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    {
    return r
}
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Fail"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == Some.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() this

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

class Outer {
    private companion object {
        val result = "OK"
    }

    val test: String

    init {
        test = result
    }
}
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput(5)
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
    val a = ByteArray(5)
    val x = a.iterator()
    var i = 0
    while (x.hasNext()) {
        if (a[i] != x.next()) return "Fail $i"
        i++
    }
    return "OK"
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yò// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          x -> null
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is String -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y?// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: (arg:Int, f :  () -> Int) -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = 10.toByte()?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val z: T?) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .foo { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput()) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(42) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.x > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // !LANGUAGE: +FunctionTypesWithBigArity
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: String, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); B(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class test(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : toString()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  s(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  Foo.prop

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (test(i))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .Foo()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return "OK"
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: box) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y”// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
    if (a.method != null) {
        a.method!!()
    }
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val String: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> MyString =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.box(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  1.let { it }
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (prop != 1)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yV// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { prop, old, new -> }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(list4: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $o")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (l[0] != 3 && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  a.z() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          z.foo("") != "Z" -> "Fail #1"
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import Game.*

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yB// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  describeSendBuffered().node.s

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is blowUpHorribly -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return inner()
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown() : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(i)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : X("inner")
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is Int -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yH// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let {x = 3}

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput("abc") {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(Char.MIN_VALUE)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output(1)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = i.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { Int ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\OK".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          3 -> r = 3
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return String

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .a { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".x(1)

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = String.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> String = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  infix val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput("OK")) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.Data > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y0// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: (String) -> String =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : S()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(object : Runnable {
            public override fun run() {
                v = v + 1
            }
        }.run() + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return getValue

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(result)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if ((a as B).foo())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class T
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yÏ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (x < 0) -x else x

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yô// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { {
    if (Z::test.invoke(Z(42)) != 42) throw AssertionError()
    if (L::test.invoke(L(1234L)) != 1234L) throw AssertionError()
    if (S::test.invoke(S("abcdef")) != "abcdef") throw AssertionError()

    return "OK"
} }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y?// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = localExtensionOnNullableParameter().value?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { String ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yª// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
        return "Wrong elements for MaxUI..MaxUI: $list1"
    }

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import count.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null += second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.range1(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(l)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return result

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun alt() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          !(x <= y) -> "Fail !($x <= $y)"
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yé// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also { ok }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.nx)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .String { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

var inner = 1

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: BK) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(T)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.A

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(String.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  String.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.r.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> changer()
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("fail 5"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.list2)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: Int.(Int)->Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == C.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: toByte): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = result.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return bar(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.A > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return value

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y2// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  const val MaxUL = ULong.MAX_VALUE
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return String(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::a
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun z2() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt(2)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(A.bNullable)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(a.str = "OK")
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : A<String>()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package x

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y8// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull("foo;", z + c.str)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> s = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.Outer()?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y]// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun Any.(): String {
return  "239" + this
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : Int()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  String.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y/// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(compareTo))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first = null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(5u) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: String) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y2// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(getCopyToArray)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class id(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return Int(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y4// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(1u, 2u, 3u, 4u))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return Id("OK")
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $AssertionError")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.three.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.Any)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y2// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(Identifier.init(true))
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { AssertionError() }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split("K").let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.j())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is String -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.Int.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : greater5()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y9// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.castToString<Any?>(null)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yJ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return foo(4, e = 8, f = 15, w = 16, aa = 23, ff = 42)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y¸// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { this }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yf// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { (x, y, z) -> x + y + z.toString() }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second = null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, T)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(box).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val range0: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun x(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(greater4.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y´// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  Outer(null).test().fn?.invoke()

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018



import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: String): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(T1.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : y() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yV// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let {
        a = 3
    }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { String(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(box.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yT// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() {
    return when (f()) {
        B.FAIL -> "fail"
        A.OK -> "OK"
    }
}

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y-// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : ArrayList<Any>()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : Father()
y	ê// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun box(): String {
    val list1 = ArrayList<UInt>()
    val range1 = 5u downTo 3u
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<UInt>(5u, 4u, 3u)) {
        return "Wrong elements for 5u downTo 3u: $list1"
    }

    val list2 = ArrayList<UInt>()
    val range2 = 5u.toUByte() downTo 3u.toUByte()
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<UInt>(5u, 4u, 3u)) {
        return "Wrong elements for 5u.toUByte() downTo 3u.toUByte(): $list2"
    }

    val list3 = ArrayList<UInt>()
    val range3 = 5u.toUShort() downTo 3u.toUShort()
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<UInt>(5u, 4u, 3u)) {
        return "Wrong elements for 5u.toUShort() downTo 3u.toUShort(): $list3"
    }

    val list4 = ArrayList<ULong>()
    val range4 = 5uL downTo 3uL
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<ULong>(5u, 4u, 3u)) {
        return "Wrong elements for 5uL downTo 3uL: $list4"
    }

    return "OK"
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = append(msg)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : L3(3.14)
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y1// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + AssertionError.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : ()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.x()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::String
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (myEquals != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y*// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  Derived.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package getter

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(C1().toString())
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && String != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == items.add(this))
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.s(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import box.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "O"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::L
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Int -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = a.compareTo(b)

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y,// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.doSomething())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): create {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y­// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun box(): String {
    val a = A()
    a.setMyStr()
    return a.getMyStr()
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : T1()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yı// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
class A
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .t { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == z.x)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.Array.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val sb = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::M
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == kotlin.reflect.KProperty)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      callback()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import 5u.toUByte().exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y)// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { outerO + localK }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : Base()
y+// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : Exception(msg)
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y(// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
sealed class CalcInput
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

    ?.also {// parsing succeeded so return it
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0 }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: ): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import .InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
           -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second= words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknownval input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input..let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println() }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first!= null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () ->Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: , val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : ()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
 class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
       (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val  = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line 

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: ) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> (input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private  output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import 

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> ("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText  "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size  2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is  -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine {line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() 
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: ) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput( {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second  words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = 
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  constval commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: ): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(valfirst: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE). { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealedclass CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yê// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + )
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main( {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package 

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine  ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
   input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
   (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlinsystem.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object  : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yø// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { printlnvalue) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = (line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String):  {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val : Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

 class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt ->output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReaderSystem.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      returnTwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand ->::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = .trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
           TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if ()
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) 

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = wordsgetOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second =words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) :CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if ()
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yA// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let 

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      ()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private  bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) :CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val : () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

 fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts  output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim(
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is  -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

       continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line:String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation:  =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

privatefun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y=// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown  output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          isTwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input. + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yã// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also 

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when(val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yì// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else 

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit  { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
           Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return 
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt)
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 wordsinput.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcessfun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import javaio.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculatorimport java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yZ// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput 

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

importjava.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val  = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank()
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = 
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation:  -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println"Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return 

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::byeis Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    valfirst = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yı// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also // parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is  -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if(input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt(
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }


private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
       TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input"
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String: CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts ->output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

 parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() 

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin..exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?. {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown ->output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yú// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() 
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = {  }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = {println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any):  = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknownline)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput)
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return ()
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit ={ println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : () {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText= "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import .system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704


package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
objectEmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  inputsplit(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output( + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y_// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess



private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput)
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first+ input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first  null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
           EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yj// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() 

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

 fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  .toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is  -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!");exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String) CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () ->  = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }// Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input:String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second:Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input)
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered)
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else  (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : ()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknownreturn Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
     first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main(){
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + .second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine-> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"

data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s"toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println(""); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
dataclass Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let {  ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { (value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class (val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}


object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    . { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt)
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output()
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.ioInputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == )
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, valsecond: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input ==ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleIntval value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second  null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine {  ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
 class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> 
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> 
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input =line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex(

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return 
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  .split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput(
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
     EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : 
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
           ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null &&  != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      returnUnknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class (val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if ( == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: ) -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
 class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (valinput = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return 
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println; exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it)
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText ="/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + inputsecond)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first !=  && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()}
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data  SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yí// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
         (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInputline: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = 

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let {words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts( first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () ->  =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop(){}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
       Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered(
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation(
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = .getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand: CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when ( input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
 kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

funparseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader()
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: ) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when () {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
dataclass TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) 

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader


fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = ) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt())
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if ( != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknownline)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if(first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if ()
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return 
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

 calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = 

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yé// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (inputisBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first  words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { ; exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output()
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return (first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommandinput.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input= line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return (line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y	// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = .getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
   val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
     second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return ((it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) :CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if ()
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : ()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}data class Unknown(val input: String) : CalcInput()
y»// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)}

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(valinput: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit= { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int,val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

valWHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val  = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand-> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!") exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }



private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): ()-> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data classUnknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input  ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if(words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y#// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = ""
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String)  CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any):() -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLineelse if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReaderimport kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y%// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

 WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split.let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input ")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation:() -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y"// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y // Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size> 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y&// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull) // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine :CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input  line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yö// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()

data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private funnoop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y°// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine 
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y'// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInputline)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y!// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

 fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
y$// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun () {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yû// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =

          is EmptyLine -> ::noop
          is SingleInt -> output(input.value)
          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
yû// Original bug: KT-38704
// Duplicated bug: KT-17018

package calculator

import java.io.InputStreamReader
import kotlin.system.exitProcess

fun main() {
  InputStreamReader(System.`in`)
    .buffered()
    .forEachLine { line ->

      val continuation: () -> Unit =
        when (val input = parseInput(line)) {
          is EmptyLine -> ::noop

          is TwoInts -> output(input.first + input.second)
          is ExitCommand -> ::bye
          is Unknown -> output("Don't know what to do with input $input")
        }
      continuation()
    }
}

private fun bye() { println("Bye!"); exitProcess(0) }

private fun noop() {}

private fun output(value: Any): () -> Unit = { println(value) }

val WHITESPACE = "\\s".toRegex()

fun parseInput(line: String): CalcInput {
  val input = line.trim()
  if (input.isBlank())
    return EmptyLine
  else if (input == ExitCommand.commandText)
    return ExitCommand

  input.toIntOrNull() // try to parse the whole line as a single int
    ?.also {// parsing succeeded so return it
      return (SingleInt(it))
    }

  // Try to parse two ints, returning Unknown if there are more than 2 words
  input.split(WHITESPACE).let { words ->
    if (words.size > 2)
      return Unknown(line)
    val first = words.getOrNull(0)?.toInt()
    val second = words.getOrNull(1)?.toInt()
    if (first != null && second != null)
      return TwoInts(first, second)
  }

  // Failed to parse anything we understand so return Unknown
  return Unknown(line)
}

sealed class CalcInput
object EmptyLine : CalcInput()
data class SingleInt(val value: Int) : CalcInput()
data class TwoInts(val first: Int, val second: Int) : CalcInput()
object ExitCommand : CalcInput() {
  const val commandText = "/exit"
}
data class Unknown(val input: String) : CalcInput()
ÿÿ
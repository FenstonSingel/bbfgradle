¿iexportTaggdefaultnoriginalSampleyØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
gmutantsŸy// Original bug: KT-28579
// Duplicated bug: KT-17018


val e = true
if (e) {fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}} else {fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}}


fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}


val u = true
try
{fun scope(action: () -> Unit): Unit = TODO()}
catch(e: Exception){}
finally{}


enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y0// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()


val e = false
when (e) {
 true -> {enum class FakeExhaustive { SINGLE }}
 else -> {enum class FakeExhaustive { SINGLE }}
}


class Test {
    fun add(other: Test): Test = TODO()
}
yA// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }


val g = true
when (g) {
 true -> {class Test {
    fun add(other: Test): Test = TODO()
}}
 else -> {class Test {
    fun add(other: Test): Test = TODO()
}}
}

y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() 
val c = false
try
{{
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}}
catch(e: Exception){}
finally{}


fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = 
val y = false
when (y) {
 true -> {TODO()}
 else -> {TODO()}
}


enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    
val l = false
when (l) {
 true -> {var res = Test()}
 else -> {var res = Test()}
}


    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yä// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    
val i = false
if (i) {scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }} else {scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }}

}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(
val k = false
when (k) {
 true -> {action: () -> Unit}
 else -> {action: () -> Unit}
}
): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yü// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = 
val s = true
if (s) {TODO} else {TODO}
()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yþ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { 
val l = true
if (l) {SINGLE} else {SINGLE}
 }

class Test {
    fun add(other: Test): Test = TODO()
}
y.// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    
val x = true
when (x) {
 true -> {fun add(other: Test): Test = TODO()}
 else -> {fun add(other: Test): Test = TODO()}
}

}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = 
val p = false
try
{Test()}
catch(e: Exception){}
finally{}


    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yý// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    
val m = true
if (m) {scope} else {scope}
 { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): 
val m = false
when (m) {
 true -> {Unit}
 else -> {Unit}
}
 = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = 
val u = false
try
{TODO()}
catch(e: Exception){}
finally{}

}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = 
val a = false
when (a) {
 true -> {Test}
 else -> {Test}
}
()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope 
val z = true
if (z) {{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }} else {{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }}

}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(
val y = false
if (y) {other: Test} else {other: Test}
): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = 
val p = false
try
{TODO}
catch(e: Exception){}
finally{}
()
}
yð// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope 
val v = true
when (v) {
 true -> {{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }}
 else -> {{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }}
}

}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yü// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): 
val u = true
if (u) {Test} else {Test}
 = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { 
val n = false
if (n) {// This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }} else {// This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }}

    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y}// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        
val n = false
when (n) {
 true -> {val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }}
 else -> {val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }}
}

    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yý// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> 
val o = false
if (o) {Unit} else {Unit}
): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: 
val x = false
when (x) {
 true -> {Test}
 else -> {Test}
}
): Test = TODO()
}
yO// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = 
val g = false
if (g) {when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }} else {when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }}

    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y // Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (
val t = true
when (t) {
 true -> {FakeExhaustive.SINGLE}
 else -> {FakeExhaustive.SINGLE}
}
) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (
val g = false
when (g) {
 true -> {FakeExhaustive}
 else -> {FakeExhaustive}
}
.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.
val p = false
try
{SINGLE}
catch(e: Exception){}
finally{}
) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> 
val o = true
try
{res::add}
catch(e: Exception){}
finally{}

        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (
val u = true
when (u) {
 true -> {Test}
 else -> {Test}
}
) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y!// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            
val s = false
when (s) {
 true -> {FakeExhaustive.SINGLE}
 else -> {FakeExhaustive.SINGLE}
}
 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> 
val z = true
try
{res}
catch(e: Exception){}
finally{}
::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yü// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::
val p = false
if (p) {add} else {add}

        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> 
val l = false
when (l) {
 true -> {Test}
 else -> {Test}
}
 = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            
val c = true
if (c) {FakeExhaustive} else {FakeExhaustive}
.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.
val w = false
when (w) {
 true -> {SINGLE}
 else -> {SINGLE}
}
 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yý// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (
val e = false
if (e) {Test} else {Test}
) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y£// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

(
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope ({ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    })
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ((Test)) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }!!
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()!!
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO!!()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test!!) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): (Unit)? = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (() -> Unit)?): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): (Test)? = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> (Unit)?): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: (Test)?): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ((Test) -> Test)? = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> (Test)? = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ((Test)?) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE: {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other) Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

TODO

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) SINGLE Test = when (FakeExhaustive.->) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.Unit) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> SINGLE): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOTest)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: (): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            res -> FakeExhaustive.SINGLE::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(scope

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun )(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } {
    var res = Test()

    scope ()
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ({
    fun add(other: Test): Test = TODO()
}) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test Test
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(Test: other): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: res -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> (Test)::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): action: () -> Unit = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun Test(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: scope): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ->
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) // Original bug: KT-28579 Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var } = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
res

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = fun

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    Test() add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test Test when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: =): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) =
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test { TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Unit) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Test = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = )
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val funcFakeExhaustive.SINGLE -> res::add (Test) -> Test = when (FakeExhaustive.SINGLE) {
            :
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.enum) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

SINGLE class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    enum class FakeExhaustive { SINGLE } { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

scope

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(Unit

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> )): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TestSINGLE -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { ) }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

{ SINGLE } class FakeExhaustive enum

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: add = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun (Test) -> Test(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (Unit -> )): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var Test = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): res = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { (
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope// This is crucial. If the expression is part of the main method, the code is compiled as expected.action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

TODO main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = fun()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (enum) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

FakeExhaustive.SINGLE class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> class = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

Test Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope fun
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> } = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE Test

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainaction: () -> Unit) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope((): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE Unit res::add
        }
    }
}

fun scope(action: () -> ->): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    fun
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    } add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.)) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO(SINGLE
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE.SINGLE) {
            FakeExhaustive -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TODO()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = Test
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res TODO Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = =()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = FakeExhaustive

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Test().SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(Test

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class ) {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    Test { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (scope) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (enum) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

Test class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

add

enum class FakeExhaustive { SINGLE }

class Test {
    fun fun scope(action: () -> Unit): Unit = TODO()(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(TODO

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = )()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() TODO

fun scope(action: () -> Unit): Unit = {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main({ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } {
    var res = Test()

    scope )
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(class Test {
    fun add(other: Test): Test = TODO()
}): Unit = TODO()

enum class FakeExhaustive { SINGLE }

action: () -> Unit
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: : = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test)(Test) -> Test Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (() -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addTestother: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.{) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test SINGLE
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLESINGLE {
            FakeExhaustive.) -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action) (: -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun class Test {
    fun add(other: Test): Test = TODO()
}() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

main
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): ) = TODO(Test
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): = Unit TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

class

enum class FakeExhaustive { SINGLE } Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    TODO res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = var()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Testwhen -> Test = ) (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
scope

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun // Duplicated bug: KT-17018(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() }
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        {
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test () -> Unit when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: =): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: () -> Unit = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (Test) -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Test()

enum class FakeExhaustive { SINGLE }

class TODO {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: when = (Test) -> Test (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> { = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test Test
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    Test add(other: fun): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test:

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other() Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(TODO: () -> Unit): Unit = action()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () { Unit): Unit = TODO()

enum class FakeExhaustive -> SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit}: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
)
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> resaddadd
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun ::(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TODO) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Test()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }()

    scope Test
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope action
}

fun scope({ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: res::add = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> (Test) -> Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ((other: Test)) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addTest: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(Unit {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> )): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { () }

class Test {
    fun add(other: Test): Test = TODOSINGLE
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope when // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = { (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } main() {
    var res = Test()

    scope fun
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit)TODO Unit = :()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testfun

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    () add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Testother: Test -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add()): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () Test Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): -> = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    var res = Test()

    scope { {
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    fun
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = {()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test Test
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope TODO
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.) -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(SINGLE

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = TestTest

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val Test: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class func {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::(
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODOadd)
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testscope)

    ( { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = fun()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    Test add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when ((.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addFakeExhaustiveother: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> UnitTest: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: )): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.=) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit SINGLE TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(SINGLE: () -> Unit): Unit = TODO()

enum class FakeExhaustive { action }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope enum class FakeExhaustive { SINGLE } // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

{

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE} {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
)
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainTODO) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = (()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope }
{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (() -> Unit) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        ( func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addvalother: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive()SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO.

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope ()
}

fun scope(action: { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) fun
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    { add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Test = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Unit = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) :
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test){ Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add()other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeSINGLEaction: () -> Unit): Unit = TODO()

enum class FakeExhaustive { ( }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test() = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.action -> res::add
        }
    }
}

fun scope(SINGLE: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::)
        }
    }
}

fun scope(action: (add -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Unit) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = .

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustiveTest()SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): () = TODOTest
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> Test::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): res = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: TODO = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = (Test) -> Test()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOenum class FakeExhaustive { SINGLE }

()

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    Unit { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> scope): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> other::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(res: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (->) Test Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (}) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        Test
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (( -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add)other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        TODO() func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = val
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(FakeExhaustive.SINGLE {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when ()) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (res.SINGLE) {
            FakeExhaustive.SINGLE -> FakeExhaustive::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::enum class FakeExhaustive { SINGLE }
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

add

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: SINGLE) -> Unit): Unit = TODO()

enum class FakeExhaustive { ( }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testwhen

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = () (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(fun scope(action: () -> Unit): Unit = TODO() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        TODO()
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    TODO add(other: Test): Test = fun()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: enum class FakeExhaustive { SINGLE }): Unit = TODO()

() -> Unit

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) TODO()
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = {

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

var res = Test() main() {
    fun

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope Test
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    Test

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): var res = Test() = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.Test -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): SINGLE = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) (
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO{)
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: Test -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    (
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO})
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.(action: () -> Unit) -> res::add
        }
    }
}

fun scopeSINGLE: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val funcadd (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res:::
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.enum class FakeExhaustive { SINGLE } -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

SINGLE

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (SINGLE) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.Test -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            TODO -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = FakeExhaustive.SINGLE()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = { SINGLE }()

enum class FakeExhaustive TODO

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (add) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            (action: () -> Unit).SINGLE -> res::add
        }
    }
}

fun scopeFakeExhaustive: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }() {
    var res = Test()

    scope main
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
{

fun main() {
    var res = Test()

    scope // Duplicated bug: KT-17018 // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            : -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test)FakeExhaustive.SINGLE Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(otherTest Test): : = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: enum = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

(Test) -> Test class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() SINGLE
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { { }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
Test

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): } = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            (other: Test).SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addFakeExhaustive: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main-> {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () () Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            TODO
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = FakeExhaustive.SINGLE -> res::add()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(enum class FakeExhaustive { SINGLE }

)

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () add Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun ->(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test() -> Unit

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ()): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeclass: Unit = TODO()

enum (action: () -> Unit) FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope:: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test)(action: () -> Unit) Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

} class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
enum
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> SINGLE = when (FakeExhaustive.Test) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> : = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(otherTest Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { add
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun // This is crucial. If the expression is part of the main method, the code is compiled as expected.(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> } = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
Test

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (TODO().SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = FakeExhaustive

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            : -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(otherFakeExhaustive.SINGLE Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> }): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
Unit
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = TestFakeExhaustive

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class () { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.res -> SINGLE::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE() {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope )
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive:SINGLE -> res::add
        }
    }
}

fun scope(action. () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    add

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun var res = Test()(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: TestTest: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope({: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test action
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

{ SINGLE }

enum class FakeExhaustive fun scope(action: () -> Unit): Unit = TODO()

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() class

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

{
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
} Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Test) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): FakeExhaustive.SINGLE = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope:action( () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            action -> res::add
        }
    }
}

fun scope(FakeExhaustive.SINGLE: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> SINGLE): Unit = TODO()

enum class FakeExhaustive { Unit }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(fun add(other: Test): Test = TODO()): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    action: () -> Unit
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.() -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOSINGLE

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainTODO()) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = (
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(Test {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class ) {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Unit
        }
    }
}

fun scope(action: () -> FakeExhaustive.SINGLE -> res::add): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

Test class FakeExhaustive { SINGLE }

class Test {
    fun add(other: enum): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.other: Test) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(SINGLE): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope fun
}

{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustiveenumSINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

. class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope SINGLE
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TODO()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Test

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) fun add(other: Test): Test = TODO()
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    {
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when { SINGLE }FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive (

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Unit.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> FakeExhaustive): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> {
    fun add(other: Test): Test = TODO()
}::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test res
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() Test
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): { = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.{) SINGLE
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Unit.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): FakeExhaustive = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() add

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope (
}

fun scope(action: { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE =

class Test {
    fun add(other: Test): Test } TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { {
    fun add(other: Test): Test = TODO()
} }

class Test SINGLE
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res (Test) Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: = -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = TestSINGLE

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { () }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> :): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(otherUnit Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope TODO
}

fun scope(action: () -> Unit): Unit = { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (FakeExhaustive) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class Test { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: TODO() = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = (Test) -> Test

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): add = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Test.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: FakeExhaustive): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLETODO {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = )()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (() -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOTest)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> TODO::add
        }
    }
}

fun scope(action: () -> Unit): Unit = res()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun FakeExhaustive(action: () -> Unit): Unit = TODO()

enum class scope { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: TODO) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = (()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive)SINGLE -> res::add
        }
    }
}

fun scope(action: (. -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.() -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODOSINGLE
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            {
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive FakeExhaustive.SINGLE -> res::add SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        Test
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test:)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other( Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testenum

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

() class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        TODO
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Unit()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class {
    fun add(other: Test): Test = TODO()
} { SINGLE }

class Test FakeExhaustive
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: FakeExhaustive.SINGLETest) -> Test = when (FakeExhaustive.SINGLE) {
            ( -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        TODO func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = val()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> . = when (FakeExhaustive.SINGLE) {
            FakeExhaustiveTestSINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

( main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: fun) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> ) = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(Test

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } scope
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(add

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun )(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (:.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test)FakeExhaustive Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () } Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE ->

class Test {
    fun add(other: Test): Test = TODO()
}
yØ(Test) -> Test
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: // Original bug: KT-28579 = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

(

fun scopefun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = scope

    Test() { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.Unit) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): SINGLE = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val (: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOfunc)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE enum res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

-> class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

Unit

fun scope(action: () -> Unit): fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
} = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: TestTest) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): ( = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) SINGLE
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { { }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addTestother: Test): ( = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = TestFakeExhaustive)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class ( { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Unit = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> (Test) -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope Unit
}

fun scope(action: () -> Unit): { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val scope: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun func(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        . func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustivevalSINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(TODO()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = )
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope action: () -> Unit // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope({): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test}

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
()
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    res { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> scope::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TestTest -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): ) = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ((Test) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (}) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    Test
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            ::.SINGLE -> resFakeExhaustiveadd
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = (Test) -> Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) TODO() Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = ->
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> {
    fun add(other: Test): Test = TODO()
} = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test Test
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = add
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): ( = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODOUnit)
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = action()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Test: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    =
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: FakeExhaustive): Unit = TODO()

enum class () -> Unit { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(Test {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> ) = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test FakeExhaustive.SINGLE when (FakeExhaustive.SINGLE) {
            = -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): SINGLE = TODO()

enum class FakeExhaustive { Unit }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = {
    fun add(other: Test): Test = TODO()
}

enum class FakeExhaustive { SINGLE }

class Test TODO()
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (other: Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main((Test) -> Test {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ) = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit ) TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO(=
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE (action: () -> Unit) res::add
        }
    }
}

fun scope->: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive{SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test .
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (TODO.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = FakeExhaustive()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
SINGLE

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { } }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.class Test {
    fun add(other: Test): Test = TODO()
}) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

SINGLE
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun (other: Test)add: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustiveUnitSINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> .): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = () (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: when -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (enum class FakeExhaustive { SINGLE }.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

FakeExhaustive

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test TODO when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = =()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Test -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): FakeExhaustive.SINGLE = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class add {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(action: () -> Unit)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> )Unit: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main=) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit ( TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun TODO(action: () -> Unit): Unit = scope()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = :

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(actionTest() () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = FakeExhaustive()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class Test { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main.) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive(SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainUnit {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> ()): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = FakeExhaustive (when.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
Unit

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> // Duplicated bug: KT-17018): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        {
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeenum class FakeExhaustive { SINGLE }action: () -> Unit): Unit = TODO()

(

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

(other: Test)

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addfun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun (() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopemainaction: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.(other: Test)) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addSINGLE: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> fun add(other: Test): Test = TODO()::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    res
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = FakeExhaustive()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Test.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun Unit() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> main): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
main

fun // Duplicated bug: KT-17018() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Test -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): (Test) = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (add.SINGLE) {
            FakeExhaustive.SINGLE -> res::FakeExhaustive
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun Unit(action: () -> scope): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(actionUnit () -> :): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (FakeExhaustive) -> Test = when (Test.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope Test // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): { = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        TODO
    }
}

fun scope(action: () -> Unit): Unit = }()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> FakeExhaustive.SINGLE = when (Test) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit)= Unit : TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainTODO()) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = (

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = }

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    Test()
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun )(action: () -> Unit): Unit = TODO(scope

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() ->
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) { Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun other(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(scope: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope ( // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO{)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: TODO -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = ()()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } = (Test) -> Test
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope } // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE {

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(Test {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: )): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val funcTODO (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = :()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.:) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(otherSINGLE Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainadd) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::(
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() Test

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
} {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (TestTest -> ) = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            ->
        }
    }
}

fun scope(action: () FakeExhaustive.SINGLE -> res::add Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit(: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add)other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Test: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: action): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Unit) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): FakeExhaustive.SINGLE = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Unit): action: () -> Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (enum.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

FakeExhaustive class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Test -> (Test) = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { other: Test }

class Test {
    fun add(SINGLE): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: SINGLE = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.(Test) -> Test -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> ( = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeTestaction: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> } = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        Test
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res:::
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test)add Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    () -> Unit

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: var res = Test()): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Unit

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Test() = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> TODO = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = Test()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    ( { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOscope)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE action res::add
        }
    }
}

fun scope(->: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainres::add) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> (
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

)

class Test {
    fun add(other: Test): Test = TODO(enum class FakeExhaustive { SINGLE }
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

enum

fun scope(action: () -> Unit): Unit = TODO()

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
} class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: { -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive (Test) SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
{
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun main() // Duplicated bug: KT-17018

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE Unit res::add
        }
    }
}

fun scope(action: () -> Unit): -> = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope )
}

fun scope(action: () -> Unit{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res Unit Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> =): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
TODO

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = // Duplicated bug: KT-17018()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main(SINGLE {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { ) }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        }
    val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() Test()
    var res = {

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> other: Test::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(res): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val funcother: Test (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(:): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = }()

enum class FakeExhaustive { SINGLE TODO

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = fun

enum class FakeExhaustive { SINGLE }

class Test {
    TODO() add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(actionSINGLE () -> Unit): Unit = TODO()

enum class FakeExhaustive { : }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() Test
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class { {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() FakeExhaustive
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when ({.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): class Test {
    fun add(other: Test): Test = TODO()
} = TODO()

enum class FakeExhaustive { SINGLE }

Unit
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Unit.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> FakeExhaustive): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: other -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add((Test): Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = other()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(Test: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = Unit
    }
}

fun scope(action: () -> when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res FakeExhaustive Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            =.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        Unit
    }
}

fun scope(action: () -> Unit): } = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = :()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(actionTest () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): FakeExhaustive = TODO()

enum class Unit { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            (.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODOFakeExhaustive)
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(:)action: () -> Unit Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            other.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(FakeExhaustive: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.class -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum SINGLE FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopefun add(other: Test): Test = TODO()action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    (
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope TODO()
}

fun scope(action: () -> Unit): Unit = { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: {
    fun add(other: Test): Test = TODO()
} = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test (Test) -> Test
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum Test FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): class = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO{ SINGLE }

enum class FakeExhaustive ()

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Unit = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE: {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action) () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: SINGLETest) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { ( }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() fun add(other: Test): Test = TODO()

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testadd

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::()
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.() {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODOSINGLE)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    {
    fun add(other: Test): Test = TODO()
}
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit:) Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (action: () -> Unit) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { res
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> // This is crucial. If the expression is part of the main method, the code is compiled as expected.::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = SINGLE
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.Test) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: SINGLE): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
Test

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: }): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: (Test) -> Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainTest) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (() -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val { SINGLE }: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive func

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Unit.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): FakeExhaustive = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.) -> res::add
        }
    }
}

fun scope(action: () -> UnitSINGLE: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { Test
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testval func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        })

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        (
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): () = TODOUnit

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    :
}

fun scope(actionscope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { )
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO(// This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

) scope(action: () -> Unitfun: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    Unit { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): scope = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (res::add) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (fun scope(action: () -> Unit): Unit = TODO()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

Test

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit)Test Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): : = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> =): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test Unit TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: TODO): Test = Test()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when ().SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (FakeExhaustive -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope . // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive{SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: Unit): () -> Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { FakeExhaustive
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            // This is crucial. If the expression is part of the main method, the code is compiled as expected..SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope Unit
}

fun scope(action: () -> { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = scope
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = FakeExhaustive.SINGLE (FakeExhaustive.SINGLE) {
            when -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

TODO

fun scope(action: () -> Unit): Unit = fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope((: action) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainadd {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::()
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when ((action: () -> Unit).SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeFakeExhaustive: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() class

fun scope(action: () -> Unit): Unit = TODO()

enum {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
} FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val SINGLE: (Test) -> Test = when (FakeExhaustive.func) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeaction(: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when {FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive ( SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() ()
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO{

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = FakeExhaustive.SINGLE -> res::add()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Test
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE Test res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): -> = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val funcUnit (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): : = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::(
        }
    }
}

fun scope(action: add) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.() -> res::add
        }
    }
}

fun scope(action: SINGLE -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add((): Test): Test = TODOother
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO(()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Testscope

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun ()(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.class Test {
    fun add(other: Test): Test = TODO()
} -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

SINGLE
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

{
    fun add(other: Test): Test = TODO()
} main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test fun
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = enum
    }
}

fun scope(action: () -> Unit): Unit = TODO()

when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        } class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> { SINGLE }): Unit = TODO()

enum class FakeExhaustive Unit

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test {
    fun add(other: Test): Test = TODO()
} when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test =
yØ// Original bug: KT-28579
}

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    // Duplicated bug: KT-17018
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustiveTestSINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): . = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainFakeExhaustive {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            ().SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() (
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO{)
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum () FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODOclass
}
yØ// Original bug: KT-28579
()

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO// Duplicated bug: KT-17018

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { )
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test// This is crucial. If the expression is part of the main method, the code is compiled as expected.: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope({: () -> Unit): Unit = TODO()

enum class FakeExhaustive action SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Unit): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit TODO TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = =()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    Test
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    } = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::(other: Test)
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addadd: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            )
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(FakeExhaustive.SINGLE -> res::add

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> ()): Unit = TODOUnit

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
FakeExhaustive

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (// Duplicated bug: KT-17018.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { TODO }

class Test {
    fun add(other: Test): Test = SINGLE()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> {::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive res SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = { SINGLE }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> )::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(res

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() ()
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: { -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> (::add
        }
    }
}

fun scope(action: res) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ::Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res(add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class = { SINGLE }

class Test {
    fun add(other: Test): Test FakeExhaustive TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class Test { SINGLE }

class Test {
    fun add(other: Test): FakeExhaustive = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    : res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(actionvar () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (add.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun FakeExhaustive(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val res: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> func::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive.SINGLE { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.action) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(SINGLE: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun mainTest) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class ( {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ( -> Test = when (Test)FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: ()) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: (Test -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = TestFakeExhaustive.SINGLE)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            ( -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val action: () -> Unit: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(func): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Test.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: FakeExhaustive): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> fun scope(action: () -> Unit): Unit = TODO() = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

Test

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res scope Test()

    = { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: ()): Test = TODOTest
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            !(0L == nx) -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y5// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun test(): Boolean {
        if (!::p.isInitialized) {
            p = "OK"
            return false
        }
        return true
    }

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yá// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (val o: String) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Inner): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class R {
    fun add(other: Test): Test = TODO()
}
yÂ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun foo() = 1
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Template()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: ): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Boolean = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            some(null, 2) != 2 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.list1) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (String) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.Long -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::Foo
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ÷// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    x(a, "OK")
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Int = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = D()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): a = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun x(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Short = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun i(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> i = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Byte.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun Boolean(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Int, Z) -> R = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(block: () -> String): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

open class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(field: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class Host { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ð// Original bug: KT-28579
// Duplicated bug: KT-17018

fun printtest() : String {
    return "OK"
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yï// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {

    val p = Foo.prop
    val p2 = prop
    val p3 = this.prop
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            nullDouble -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> local): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    World { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addvalue: Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Test): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> String::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): String = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var Int = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÌ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(i: Int): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (justPrint.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Int = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = test(R(0))

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var getter = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::Int
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: () -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ò// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    foo()
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = KProperty()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = A()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            sum.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// !LANGUAGE: +InlineClasses

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yû// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            minusZero -> {
                    return "fail 3"
                }
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ÿ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { prop = 2 }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> String): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(name: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            filter.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Int) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = box()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun doTest(): String {
    var s = ""
    for ((a, b) in 0..2) {
      s += {"$a:$b;"}()
    }
    return s
}

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yM// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

class Outer {
    class Nested {
        companion object {
            val O = "O"
            val K = "K"
        }
    }
    
    fun O() = Nested.O
}

class Test {
    fun add(other: Test): Test = TODO()
}
yá// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::KHolderAlias
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope {
        object { }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÞ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = CharArray(5)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> test::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (l.add(1)) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = ch()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> T): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.MINUS0F -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var x = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.A) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.sb -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = map()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Boolean = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(val f: Int): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Inner()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.String -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: T): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> Int::foo
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::this
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Int = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> box = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): String = TODO()
}
yâ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = AssertionError()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { C }

class Test {
    fun add(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            String.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yY// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { {
    val b = B("OK")
    if (b.foo() != "OK") return "fail: ${b.foo()}"
    return b.foo2()
}
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// IGNORE_BACKEND: JVM_IR
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> value = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun box() = Outer().test()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val box: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: String): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Box<Int>(1)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÆ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun foo(): String
}
yõ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive {
    operator fun invoke(i: Int) = i
}

class Test {
    fun add(other: Test): Test = TODO()
}
y	// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { result += "A.amp," }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            is Result.ParseError -> Result.ParseError(res2.productionLabel, res2.child, res2.rest)
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: UInt = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): x = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> D::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): list2 = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Array.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yò// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    // FILE: util.kt
val log = StringBuilder()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> i::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            t.prop7 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> Globals::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

companion class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yù// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

interface Test {
    fun test(): String {
        return "OK"
    }
}

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            A.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: String): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: D1): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Int): Test = TODO()
}
yà// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(0, false)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var run = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            (-1).toByte() -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> A::Inner
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.result -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::box
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yä// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun local(): Int {
        return 1 foo 1
    }
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class list1 { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = s()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun x() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Foo = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = withIndex()
}
yÂ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            10 -> ::baz
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: () -> Int = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: I): Test = TODO()
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = commands()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun debug() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (En) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> T2): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yß// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun getReferencedNameElement(): PsiElement
}
y{// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val o = Box("lorem")
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

internal open class B<T>(val x: T, val y: T) {
    constructor(x: T): this(x, x)
    override fun toString() = "$x#$y"
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> String = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    val result = (A::Inner)((::A)(), 111).result + (A::Inner)(A(), 222).result

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ô// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    mapOf()
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÆ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.b3 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { OK; }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = ok_L()
}
y-// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun box(): String {
    val list1 = ArrayList<Int>()
    val range1 = 3..9 step 2
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<Int>(3, 5, 7, 9)) {
        return "Wrong elements for 3..9 step 2: $list1"
    }

    val list2 = ArrayList<Int>()
    val range2 = 3.toByte()..9.toByte() step 2
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<Int>(3, 5, 7, 9)) {
        return "Wrong elements for 3.toByte()..9.toByte() step 2: $list2"
    }

    val list3 = ArrayList<Int>()
    val range3 = 3.toShort()..9.toShort() step 2
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<Int>(3, 5, 7, 9)) {
        return "Wrong elements for 3.toShort()..9.toShort() step 2: $list3"
    }

    val list4 = ArrayList<Long>()
    val range4 = 3L..9L step 2L
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<Long>(3, 5, 7, 9)) {
        return "Wrong elements for 3L..9L step 2L: $list4"
    }

    val list5 = ArrayList<Char>()
    val range5 = 'c'..'g' step 2
    for (i in range5) {
        list5.add(i)
        if (list5.size > 23) break
    }
    if (list5 != listOf<Char>('c', 'e', 'g')) {
        return "Wrong elements for 'c'..'g' step 2: $list5"
    }

    return "OK"
}

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y Ô// Original bug: KT-28579
// Duplicated bug: KT-17018

fun box() = ok()

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { e }

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

open class C(val grandParentProp: String)
yÑ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: () -> R = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val i: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Long()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            B().test() -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (toInt) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = String()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    IcLong { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(i)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = local()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> UInt = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÄ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            1 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun Y(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun Inner(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = from()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = fn()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yã// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = ArrayList<UInt>()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = s()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yp// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { X {
        val x = "OK"

        inner class Inner {
            fun foo() = x
        }

        val z = Inner()

        override val test = z.foo()
    }; }

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (x.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> B::value
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Unit = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::res
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: First): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (C.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y{// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { //FAIL
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: asInt): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.CapturesX) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.minus -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Z.foo("") != "Z" -> "Fail #1"
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: range0): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive {
    OK
}

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

public interface SomeTrait {
    fun foo()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::String
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÌ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            xs.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y8// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    init {
        log.append("<init>")
    }

    companion object {
        init {
            log.append("<clinit>")
        }
    }
}
yû// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

class C(val x: String) {
    constructor(n: Int) : this(n.toString())
}

class Test {
    fun add(other: Test): Test = TODO()
}
y7// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
      var s = ""
      for ((a, b) in 0.rangeTo(2)) {
        s += "$a:$b;"
      }
      return s
  }

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val foo: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // KJS_WITH_FULL_RUNTIME
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (A) -> String = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y%// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope {
        test("ok")
        test("ok", 200)
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y // Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { this + it }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (array.last) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    A { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

operator class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = a()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yO// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { {
            s += "Try";
            unsupportedEx()
            return s
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y!// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope {
        throw RuntimeException("fail")
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Long) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (T) -> Boolean = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yß// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun box(): String {
    C.ZZZ().c
    return "OK"
}

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = foo()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÉ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            x >= y -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(listOf(1).map { it.toString() }.joinToString())

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> x::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.x -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(String: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Any = TODO()
}
yß// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(giil: GIIList<Any>): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(0)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Long()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yã// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.o_plus_f1_plus_f2 -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÌ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (v1.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): sum = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.s -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun println(s: String) {
}
}
y.// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun box(): String {
    for (x in ShortArray(5)) {
        if (x != 0.toShort()) return "Fail $x"
    }
    return "OK"
}
}
yâ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = AssertionError()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    testOverridden(Z(123))
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): C = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: r): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (value) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (s: S) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> box::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun Int(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    count { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÞ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = unaryMinus()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::C
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yç// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    const val MaxL = Long.MAX_VALUE

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.A -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { s }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Unit()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { ONE, }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): list = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): notInLong = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Z?): Test = TODO()
}
ya// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when {
        z.foo("") != "Z" -> "Fail #1"
        d.foo("") != "Z" -> "Fail #2"
        c.foo("") != "Z" -> "Fail #3"
        b.foo("") != "Z" -> "Fail #4"
        a.foo("") != "Z" -> "Fail #5"
        else -> "OK"
    }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = a()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            a.equals(b) -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { foo(it::simple) }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y4// Original bug: KT-28579
// Duplicated bug: KT-17018

fun box(): String {
    val list1 = ArrayList<Int>()
    val range1 = 3..8 step 2
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<Int>(3, 5, 7)) {
        return "Wrong elements for 3..8 step 2: $list1"
    }

    val list2 = ArrayList<Int>()
    val range2 = 3.toByte()..8.toByte() step 2
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<Int>(3, 5, 7)) {
        return "Wrong elements for 3.toByte()..8.toByte() step 2: $list2"
    }

    val list3 = ArrayList<Int>()
    val range3 = 3.toShort()..8.toShort() step 2
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<Int>(3, 5, 7)) {
        return "Wrong elements for 3.toShort()..8.toShort() step 2: $list3"
    }

    val list4 = ArrayList<Long>()
    val range4 = 3L..8L step 2L
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<Long>(3, 5, 7)) {
        return "Wrong elements for 3L..8L step 2L: $list4"
    }

    val list5 = ArrayList<Char>()
    val range5 = 'a'..'d' step 2
    for (i in range5) {
        list5.add(i)
        if (list5.size > 23) break
    }
    if (list5 != listOf<Char>('a', 'c')) {
        return "Wrong elements for 'a'..'d' step 2: $list5"
    }

    return "OK"
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

// KJS_WITH_FULL_RUNTIME
class C(val i: Int) {
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = b()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yá// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Trait<String>): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): bar = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun y(other: Test): Test = TODO()
}
yÞ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Array<Int> = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Boolean) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> A::foo
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = A()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.D) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (foo.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { RED, }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> test6 = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class box { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun a(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÌ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            ss.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y>// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { {
        throw AssertionError("Loop should not be executed")
    }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = Long()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun A() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = box()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            myEquals1.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.String) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yã// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var AssertionError = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Outer = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(X: Test): Test = TODO()
}
yá// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

enum class Test(val x: String, val closure1: () -> String) {
    FOO("O", run { { FOO.x } }) {
        override val y: String = "K"
        val closure2 = { y } // Implicit 'FOO'
        override val z: String = closure2()
    };

    abstract val y: String
    abstract val z: String

    fun test() = closure1() + z
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun i() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yã// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (f: T.() -> Unit) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            !(x == ax) -> "Fail 18"
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = it()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            x > y     -> "Fail $x > $y"
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.a) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Father = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y†// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        private var obj: JClass? = this
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.innerGetter) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { L(it.long + 1L) }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (predicate) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var box = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: T = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÜ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: contents): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(x: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.foo -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun size(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = B<Int>()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(Nested: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> hashCode::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(): Test = TODO()
}
yc// Original bug: KT-28579
// Duplicated bug: KT-17018

fun box(): String {
    var i = 0
    do {
        if (i++ > 100) break;
        continue;
    } while(false)
    if (i != 1) return "Fail 1, expected 1, but $i"

    i = 0
    do {
        if (i++ > 100) break;
        continue;
    } while(i<10)
    if (i != 10) return "Fail 2, expected 10, but $i"

    i = 0
    do continue while(i++<10)
    if (i != 11) return "Fail 3, expected 11, but $i"

    return "OK"
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.myEquals -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(HashSet: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun b(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (String.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y // Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Delegate {
    inline operator fun getValue(t: Any?, p: KProperty<*>): String = p.name
}
yà// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = arrayOfNulls()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun b() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun s(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (get.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { box }

class Test {
    fun add(other: Test): Test = TODO()
}
yÚ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> result = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y
// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive {
    fun foo() = o_plus_f_plus_k {""}

    companion object {
        private val o = "O"
        private val k = "K"

        private inline fun o_plus_f1_plus_f2(f1: () -> String, f2: () -> String) = o + f1() + f2()
        private inline fun o_plus_f_plus_k(f: () -> String) = o_plus_f1_plus_f2(f) { k }

    }
}

class Test {
    fun add(other: Test): Test = TODO()
}
y×// KJS_WITH_FULL_RUNTIME
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = prop()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÇ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(l): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { if (prop == 1) "OK" else "fail" }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Any = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            !eq(ONE, 1) -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÝ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = withIndex()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class add { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: String = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = i()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun ok(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(i: Int): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): add = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class Unit { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(b: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): I = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: z): Test = TODO()
}
y‰// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // var bug: Int = 1,
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yý// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

class A {
    fun foo(
        p00: A, p01: A, p02: A, p03: A, p04: A, p05: A, p06: A, p07: A, p08: A, p09: A,
        p10: A, p11: A, p12: A, p13: A, p14: A, p15: A, p16: A, p17: A, p18: A, p19: A,
        p20: A, p21: A, p22: A, p23: A, p24: A, p25: A, p26: A, p27: A, p28: A, p29: A
    ): String {
        return "OK"
    }
}

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // Auto-generated by org.jetbrains.kotlin.generators.tests.GenerateRangesCodegenTestData. DO NOT EDIT!
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: () -> String = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            y == nx -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> get::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> task = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            doLongReceiver(3L) -> "failed 5"
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÍ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            Z().test() -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÆ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            "." -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÛ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    toString { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    Any { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.id -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.FList) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yâ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> useScriptArgs::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = Array()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun box(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ù// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { it }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yú// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun test3() : Int {
        r3++
        ++r3
        return r3
    }
}
yØ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun box(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (Host.Companion.fn()) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÙ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: test4): Test = TODO()
}
y)// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { B {
        override val value = "OK"

        override val test = ::value.get()
    }; }

class Test {
    fun add(other: Test): Test = TODO()
}
yØ// Original bug: KT-28579
    var res = Test()

fun main() {
// Duplicated bug: KT-17018

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÈ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit):  = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func:  = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive. -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE-> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = ()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit):Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enumclass FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add}
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO)

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

 scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test) Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y í// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive {SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> ): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustiveSINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ) -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun addother: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) ->  = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test)

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test{
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ()  Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive 

class Test {
    fun add(other: Test): Test = TODO()
}
yµ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test)-> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scopeaction: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }


fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE 

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () ->Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

 class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }}
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = 

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res= Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = ()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit) Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustiveSINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test(

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE ->res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main( {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ( -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE}

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
     res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test =when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yg// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y­// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test 
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test  when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test= when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum classFakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test= TODO()
}
y Ï// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() 

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) ->Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÎ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÃ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
             -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive {  }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO(
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

     { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test 
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÏ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main) {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add: Test = TODO()
}
yË// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = ()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        valfunc: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test):  = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit =TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y ó// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope 
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y‚// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = 
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun () {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: ()-> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test =TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    varres = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res =Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

 main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y û// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { 
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() 
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun (action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÃ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when () {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action:  -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y¢// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }


yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y¿
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            .SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÊ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class  { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope{ // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val : (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y¬// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}



enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when(FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit= TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other Test): Test = TODO()
}
y´// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()



class Test {
    fun add(other: Test): Test = TODO()
}
y Ä// Original bug: KT-28579
// Duplicated bug: KT-17018



fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

classTest {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test):Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE){
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test  TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test =  (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
         func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit  TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y½// Original bug: KT-28579


fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive  SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()

yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun (other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> ::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum  FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res  Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE  res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO)
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

 Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func:(Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

funscope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yu// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { 
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO(

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope  // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope {// This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    funadd(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> resadd
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = 
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other:Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive{ SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO
}
yÒ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = 

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y×// Original bug: KT-28579
// Duplicated bug: KT-17018

funmain() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÔ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class  {
    fun add(other: Test): Test = TODO()
}
yÓ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(: Test): Test = TODO()
}
yÐ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> 
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
y·// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÄ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope: Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÖ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var res = Test

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÕ// Original bug: KT-28579
// Duplicated bug: KT-17018

fun main() {
    var  = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
yÌ// Original bug: KT-28579
// Duplicated bug: KT-17018


    var res = Test()

    scope { // This is crucial. If the expression is part of the main method, the code is compiled as expected.
        val func: (Test) -> Test = when (FakeExhaustive.SINGLE) {
            FakeExhaustive.SINGLE -> res::add
        }
    }
}

fun scope(action: () -> Unit): Unit = TODO()

enum class FakeExhaustive { SINGLE }

class Test {
    fun add(other: Test): Test = TODO()
}
ÿÿ